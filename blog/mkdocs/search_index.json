{
    "docs": [
        {
            "location": "/", 
            "text": "Project Malm\n Blog\n\n\nProject Malm\n, named after a town between Cambridge, UK where it was developed and Stockholm, Sweden where\nMinecraft was created, is an Artificial Intelligence (AI) platform that allows researchers to create challenging and\ninteresting tasks for evaluating agents, and Minecraft enthusiasts to engage in the Modding community and\nhelp advance AI. The platform is built keeping in mind recent advances in Deep Reinforcement Learning for Video Game\nplaying; however, the project is intended to be very open ended allowing for research into more general AI topics\nsuch as Multi-Agent systems, Transfer Learning, and Human-AI interaction.", 
            "title": "Home"
        }, 
        {
            "location": "/#project-malm-blog", 
            "text": "Project Malm , named after a town between Cambridge, UK where it was developed and Stockholm, Sweden where\nMinecraft was created, is an Artificial Intelligence (AI) platform that allows researchers to create challenging and\ninteresting tasks for evaluating agents, and Minecraft enthusiasts to engage in the Modding community and\nhelp advance AI. The platform is built keeping in mind recent advances in Deep Reinforcement Learning for Video Game\nplaying; however, the project is intended to be very open ended allowing for research into more general AI topics\nsuch as Multi-Agent systems, Transfer Learning, and Human-AI interaction.", 
            "title": "Project Malm&ouml; Blog"
        }, 
        {
            "location": "/Getting_Started/", 
            "text": "How does the platform work?\n\n\nAt the heart of Project Malm\n is the ability to create \"Missions\" which are essentially descriptions of\ntasks which, in broad terms, consists of the:\n\n\n\n\nMinecraft environment (world) such as the blocks, items, weather and enemies,\n\n\nObservations that an agent receives as it traverses the Minecraft environment,\n\n\nReward handlers which define what \"good\" and \"bad\" agent behavior is, or, in other words,\n    implement reward functions, and finally,\n\n\nQuit producers that define when a mission ends.\n\n\n\n\nProject Malm\n provides a simple API (a set of useful function) for creating tasks; however, for most development,\na commonly used file format which can easily be extended and is compatible with many programming languages, namely XML,\nis used.\n\n\nOne Missions are created using a programming language of your choice, agents can begin interacting with the environment\nand try to complete the mission successfully by sending commands to Minecraft and receiving rewards and observations.\n\n\nThe backend on the Minecraft side uses the well known tool in the modding community, MinecraftForge, and communication\nbetween agents and Minecraft uses sockets and JavaScript Object Notation (JSON) formatted objects.\n\n\n\n\nHow do I get up and running?\n\n\nFor playing around with Project Malm\n, a release version of the platform should suffice. However, for\ncontributing changes to the platform and creating Missions with functionality not already provided by Malm\n,\na full build will be needed.\n\n\nTo get up and running with a Release version\nvisit the \nGitHub Repo\n, scroll down to the\nREADME and follow the instructions under Getting Started.\n\n\nFor a full build, you can visit\n    \n Linux Build \n,\n    \n OSX Build \n, or\n    \n Windows Build \n as appropriate for\n    the build instruction.\n\n\n\n\nNote\n\n\nThe Download Link on the Right Pane downloads a copy of the GitHub Repository as a .zip. This works for a build.\nHowever, if you would like a release, please visit the GitHub page and follow the instructions in the readme there.\n\n\n\n\nMost of the steps in the instruction should be quite straightforward. Should you face any difficulties,\nhave a look at the\n\nTroubleshooting Wiki page\n\non GitHub for solving some common problems; however, if you do not see your problem discussed there, do post an issue on\n\nGitHub\n\nor a message on the \nGitter chat room\n\nif there are other problems you are facing.\n\n\nAs suggested in the readme, to get familiar with the interface once all the installation is done and\nthings seems to work, you can go through the\n\nTutorial\n\nwhich is currently based on Python. At this point, it is probably\ngood to note that while the platform works with other programming languages, currently most of it is focused on Python\nsimply because many AI and Machine Learning frameworks use Python and it works well as a scripting language with\na gentle learning curve, which is especially useful when creating Missions.\n\n\nThe Documentation is also be very useful. More specifically, for getting more familiar with the agent side of things,\nsuch as the functions Malm\n provides for agents to perform actions and receive observations, take a look at the\n\nAPI Documentation\n. On the\nother hand, for the Mission Generation side of things, take a look at the\n\n XML Schema Documentation\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Getting_Started/#how-does-the-platform-work", 
            "text": "At the heart of Project Malm  is the ability to create \"Missions\" which are essentially descriptions of\ntasks which, in broad terms, consists of the:   Minecraft environment (world) such as the blocks, items, weather and enemies,  Observations that an agent receives as it traverses the Minecraft environment,  Reward handlers which define what \"good\" and \"bad\" agent behavior is, or, in other words,\n    implement reward functions, and finally,  Quit producers that define when a mission ends.   Project Malm  provides a simple API (a set of useful function) for creating tasks; however, for most development,\na commonly used file format which can easily be extended and is compatible with many programming languages, namely XML,\nis used.  One Missions are created using a programming language of your choice, agents can begin interacting with the environment\nand try to complete the mission successfully by sending commands to Minecraft and receiving rewards and observations.  The backend on the Minecraft side uses the well known tool in the modding community, MinecraftForge, and communication\nbetween agents and Minecraft uses sockets and JavaScript Object Notation (JSON) formatted objects.", 
            "title": "How does the platform work?"
        }, 
        {
            "location": "/Getting_Started/#how-do-i-get-up-and-running", 
            "text": "For playing around with Project Malm , a release version of the platform should suffice. However, for\ncontributing changes to the platform and creating Missions with functionality not already provided by Malm ,\na full build will be needed.  To get up and running with a Release version\nvisit the  GitHub Repo , scroll down to the\nREADME and follow the instructions under Getting Started.  For a full build, you can visit\n      Linux Build  ,\n      OSX Build  , or\n      Windows Build   as appropriate for\n    the build instruction.   Note  The Download Link on the Right Pane downloads a copy of the GitHub Repository as a .zip. This works for a build.\nHowever, if you would like a release, please visit the GitHub page and follow the instructions in the readme there.   Most of the steps in the instruction should be quite straightforward. Should you face any difficulties,\nhave a look at the Troubleshooting Wiki page \non GitHub for solving some common problems; however, if you do not see your problem discussed there, do post an issue on GitHub \nor a message on the  Gitter chat room \nif there are other problems you are facing.  As suggested in the readme, to get familiar with the interface once all the installation is done and\nthings seems to work, you can go through the Tutorial \nwhich is currently based on Python. At this point, it is probably\ngood to note that while the platform works with other programming languages, currently most of it is focused on Python\nsimply because many AI and Machine Learning frameworks use Python and it works well as a scripting language with\na gentle learning curve, which is especially useful when creating Missions.  The Documentation is also be very useful. More specifically, for getting more familiar with the agent side of things,\nsuch as the functions Malm  provides for agents to perform actions and receive observations, take a look at the API Documentation . On the\nother hand, for the Mission Generation side of things, take a look at the  XML Schema Documentation .", 
            "title": "How do I get up and running?"
        }, 
        {
            "location": "/BuildBattle/Introduction/", 
            "text": "Goals of this Tutorial\n\n\nThis tutorial demonstrates the steps necessary to create a Project Malm\n task inspired by Minecraft Build Battles.\nAlong the way, we will briefly discuss Project Malm\n as a platform for engineering reinforcement learning (RL) tasks and\nevaluating RL agents. We will also look at many of the inner workings of the platform as appropriate including\nXML Schema Definitions and MinecraftForge, the modding backend for Project Malm\n,\nalong with resources that might help in creating mods.\n\n\nMinecraft Build Battles\n\n\nBefore we dive into Project Malm\n, given below are a few videos to illustrate what Build Battles are.\n\n\n\n \n\n \n\n\nEssentially, Build Battles are Minecraft minigames where players compete to create the most fitting\nstructure for a given theme. We will be creating a task that is more concrete and is more practical\ngiven the current state of Artificial Intelligence (AI).", 
            "title": "Introduction"
        }, 
        {
            "location": "/BuildBattle/Introduction/#goals-of-this-tutorial", 
            "text": "This tutorial demonstrates the steps necessary to create a Project Malm  task inspired by Minecraft Build Battles.\nAlong the way, we will briefly discuss Project Malm  as a platform for engineering reinforcement learning (RL) tasks and\nevaluating RL agents. We will also look at many of the inner workings of the platform as appropriate including\nXML Schema Definitions and MinecraftForge, the modding backend for Project Malm ,\nalong with resources that might help in creating mods.", 
            "title": "Goals of this Tutorial"
        }, 
        {
            "location": "/BuildBattle/Introduction/#minecraft-build-battles", 
            "text": "Before we dive into Project Malm , given below are a few videos to illustrate what Build Battles are.  \n  \n   Essentially, Build Battles are Minecraft minigames where players compete to create the most fitting\nstructure for a given theme. We will be creating a task that is more concrete and is more practical\ngiven the current state of Artificial Intelligence (AI).", 
            "title": "Minecraft Build Battles"
        }, 
        {
            "location": "/BuildBattle/Preliminaries/", 
            "text": "Prerequisites\n\n\nThis tutorial assumes that you have already completed the build instructions and are able to create a\nbuild successfully. If this is not the case, have a look at the \"How do I get up and running?\" section under\n\"Getting Started\" for the build instructions as well as some troubleshooting guidelines.\n\n\nApart from being able to create a build, there is not much else that this tutorial assumes other than some basic programming background. Most of the tutorial can be followed simply by going through the code and documentation already present in the Malm\n platform and doing some pattern matching. Pointers to \n  resources and documentation will be provided when relevant. That said, some knowledge of XML and Java or similar equivalents, say HTML and C++ respectively, will be greatly beneficial.\n\n\nSetting up an IDE\n\n\nUsing an Integrated Development Environment can greatly help in developing MinecraftForge mods and hence working with\nthe Project Malm\n platform. Since Minecraft is programmed in Java, some IDEs are\n\n recommended and used by the\nMinecraft modding community \n. These are \n IntelliJ IDEA \n and\n\n Eclipse \n.\n\n\nAt this point, if you do not already have one of the above IDEs, choose an IDE you like, download and install it.\n\n\nNow, open a command prompt or terminal and change the directory to the Malm\n directory (root) and then to the directory\ninside titled Minecraft. Now, the next few steps will\n\n vary depending on the IDE you choose to use \n.\n\n\nIf you are using Eclipse and are on\n\n\n\n\n\n\nWindows, run: \ngradlew eclipse\n\n\n\n\n\n\nLinux/Mac OS, run:  \n./gradlew eclipse\n\n\n\n\n\n\nNow, open Eclipse and point it to the eclipse folder\n\n\nIf you are using IDEA, open IDEA and select Import Project. Now, navigate to the Minecraft folder within the Malm\n directory.\nSelect \nbuild.gradle\n within the Minecraft folder.\n\n\nOnce IDEA finishes importing the project, close IDEA. In your command window, run\n\n\n\n\n\n\nFor Windows: \ngradlew genIntellijRuns\n\n\n\n\n\n\nFor Linux/Mac OS: \n./gradlew genIntellijruns", 
            "title": "Preliminaries"
        }, 
        {
            "location": "/BuildBattle/Preliminaries/#prerequisites", 
            "text": "This tutorial assumes that you have already completed the build instructions and are able to create a\nbuild successfully. If this is not the case, have a look at the \"How do I get up and running?\" section under\n\"Getting Started\" for the build instructions as well as some troubleshooting guidelines.  Apart from being able to create a build, there is not much else that this tutorial assumes other than some basic programming background. Most of the tutorial can be followed simply by going through the code and documentation already present in the Malm  platform and doing some pattern matching. Pointers to \n  resources and documentation will be provided when relevant. That said, some knowledge of XML and Java or similar equivalents, say HTML and C++ respectively, will be greatly beneficial.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/BuildBattle/Preliminaries/#setting-up-an-ide", 
            "text": "Using an Integrated Development Environment can greatly help in developing MinecraftForge mods and hence working with\nthe Project Malm  platform. Since Minecraft is programmed in Java, some IDEs are  recommended and used by the\nMinecraft modding community  . These are   IntelliJ IDEA   and  Eclipse  .  At this point, if you do not already have one of the above IDEs, choose an IDE you like, download and install it.  Now, open a command prompt or terminal and change the directory to the Malm  directory (root) and then to the directory\ninside titled Minecraft. Now, the next few steps will  vary depending on the IDE you choose to use  .  If you are using Eclipse and are on    Windows, run:  gradlew eclipse    Linux/Mac OS, run:   ./gradlew eclipse    Now, open Eclipse and point it to the eclipse folder  If you are using IDEA, open IDEA and select Import Project. Now, navigate to the Minecraft folder within the Malm  directory.\nSelect  build.gradle  within the Minecraft folder.  Once IDEA finishes importing the project, close IDEA. In your command window, run    For Windows:  gradlew genIntellijRuns    For Linux/Mac OS:  ./gradlew genIntellijruns", 
            "title": "Setting up an IDE"
        }, 
        {
            "location": "/BuildBattle/An_Overview_of_XML_and_XSD/", 
            "text": "The Building Blocks of Missions\n\n\neXtensible Markup Language or XML provides for a software and hardware \n independent way to store and transmit data. Additionally, XML is a \n language that is designed for coming up with specialized markup \n languages. For example, one could come up with a language for \n genealogy, and define tags like \nmother\n, \nfather\n, \n \nson\n, and \ndaughter\n. As a result of this ease of \n creating new languages, XML has been used in hundreds of document \n and markup language formats including MathML for specifying \n mathematical and scientific content, XHTML for extending HTML,\n the popular backbone language of the Internet, and Atom and RSS \n for delivering updates on regularly changing content. \n\n\nThough XML is generally weak syntactically, there is a specification \n which should be followed for clarity and functionality. A thorough yet \n brief introduction to the key terminology is given in the \n \n XML \n Wikipedia page \n. Given below is an even briefer view on what will \n be important, especially in the context of Project Malm\n.\n\n\n\n\n\n\nXML comprises of a string of characters. These characters may \n     generally be any \n     \n\n     Unicode character\n.\n\n\n\n\n\n\nThe characters making up an XML document are divided into markup \n     and content. These are different using simple syntactic rules.\n\n\n\n\n\n\nAs alluded to above in the example given previously, XML at its \n     core is built on tags, like many other Markup Languages. These \n     begin with \n and end with \n. More specifically, they come \n     in three flavors:\n\n\n\n\nStart-tags like \nsection\n, \n\n\nEnd-tags like \n/section\n, and \n\n\nEmpty-element tags like \nline-break /\n.\n\n\n\n\n\n\n\n\nA logical document component that either begins with a start-tag \n     and ends with a matching end-tag or consists of only an \n     empty-element tag. The characters between the start- and end-tags, \n     if any are the element's content. Examples are \n     \nGreeting\nHello, World\n/Greeting\n, \n\n     \nline-break\n/line-break\n and \n     \nline-break /\n.\n\n\n\n\n\n\nAttributes are name/value pairs that exist within a start or \n     empty-element tag. In the example below the element \nimg\n has \n     two attributes, \nsrc\n and \nalt\n:\n\n\nimg src=\"proj_malmo.jpg\" alt=\"Project Malmo Image\" /\n\n\nThe above is an empty-element tag. Another example with start- and \n end-tags, where the only attribute is \nnumber\n with a value of 3,\n is: \n\n\nstep number=\"3\"\nOpen the XML file.\n/step\n\n\n\n\n\n\nAn XML attribute can only have a single value and each attribute \n     can appear only once.\n\n\n\n\n\n\nA processor or XML parser analyzes markup and passes structured \n     information to an application. The specification places \n     requirements on what an XML processor must do or not do, but the \n     application is outside of its scope.\n\n\n\n\n\n\nNow, the last point about the processor and application is what leads us \nto XSD and JAXB, the next things to get an understanding of Missions in \nProject Malm\n. \n\n\nRules for the Building Blocks\n\n\nAs described in the previous section, XML can be used to come up with \nnew markup languages. However, there is a question of how one does this \nand in particular of how the syntax is defined. \n\n\nXML Schema Definitions or XSD formally describe \nelements in an XML document. Its purpose is to verify each piece of item\ncontent in an XML document, i.e., to parse an XML document using various \nSchemas (rules). \n\n\nWithout further ado, let's now take a look at the XSD files for Project\nMalm\n. Within the Project Malm\n root folder, look for the \nSchemas folder. In there you will find (as of this tutorial's writing \nat least), 5 files with a .xsd extension. These are namely: Mission, \nMissionEnded, MissionHandlers, MissionInit and Types. \n\n\nFeel free to go through the files and get an understanding of the \nstructure. The general format should be quite intuitive as XML is \ndesigned to be human readable while still having a well-defined syntax \nlike that of many programming languages. \n\n\nTo highlight a few points about the files and to direct your attention \nto some interesting properties of XSD, given below are somethings you \ncan try/have a read through with code snippets as appropriate for \nillustration purposes: \n\n\n\n\n\n\nAt the top of all of the files, there is the XML declaration which \n    specifies the version of XML to use and the character encoding to \n    use.  \n\n\n\n\n\n\nJust below the XML declaration, is the root element which is \n    required for XSD documents. This root element importantly contains\n    information about namespaces which are a common programming language\n    concept that prevents name conflicts (eg., when an element is \n    defined in multiple separate schema files).\n\n\nxmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n indicates that \nthe elements and data types used in the schema come from the w3 \norganizations namespace. It also specifies that elements that come\nfrom this namespace should be prefixed with xs.\n\n\nThe value of a targetNamespace, \n\nhttp://ProjectMalmo.microsoft.com\n is simply a unique \nidentifier, typically a company's project URL, that indicates \nthe elements defined by this schema come from the URL specified.\n\n\nThe default namespace is set to the same URL as the targetNamespace\nusing the \nxmlns\n attribute.\n\n\nSetting elementFormDefault to qualified indicates that any elements\ndefined in the Schema must be qualified, i.e, be associated with a \nnamespace, when used in an XML document.\n\n\n\n\n\n\nXML Schema have a lot of built-in data types including:\n    \nxs:string\n, \n    \nxs:decimal\n, \n    \nxs:integer\n, \n    \nxs:boolean\n, \n    \nxs:date\n, \n    \nxs:time\n.\n\n\n\n\n\n\nA \nSimple Element\n\n    is an XML element that contains text of one of the types included in \n    XSD or it can be a custom type. It cannot contain any other elements\n    or attributes. The syntax for defining a simple element is as\n    follows: \nxs:element name=\"xxx\" type=\"yyy\" /\n\n\n\n\n\n\nAn \n\n    Attribute\n is very similar to a simple element. Simple elements\n    cannot have attributes. The syntax for defining an attribute is \n    \nxs:attribute name=\"xxx\" type=\"yyy\" /\n\n\n\n\n\n\nA \nsimpleType\n \n    element defines a simple type and specifies the \n    constraints and information about the values of attributes or \n    text-only elements. For examples, see Types.xsd where enumerations\n    are used for definitions of simpleTypes like Colour and BlockType. \n    In particular, note the use of xs:restriction to restrict the values\n    the simpleType can take as well as to define the base type which the \n    simpleType takes, such as xs:string.\n\n\n\n\n\n\nA \nComplex Element\n\n    contains other element and/or attributes. There \n    are four types based on the contents: \n    \nempty elements\n, \n    \nonly other elements\n, \n    \nonly text\n,\n    \nand a mixture of other elements and text\n. \n\n\n\n\n\n\nComplex Elements often make use of complexTypes as well as \n    \n\n    order and occurence indicators\n. \n\n\n\n\n\n\nOrder Indicators \n\n\n\n\nThe \nall\n indicator specifies that child elements can \nappear in any order, and that each child must occur only once.\n\n\nThe \nchoice\n indicator specifies that only one of a list \nof children elements can be present.\n\n\nThe \nsequence\n indicator specifies that the child elements\nmust appear in a specific order. \n\n\n\n\n\n\n\n\nOccurrence Indicators\n\n\n\n\n\n\nThe \nminOccurs\n indicator specifies the minimum number of \ntimes an element can occur and the \nmaxOccurs\n indicator\nspecifies the maximum number of times an element can occur. \n\n\n\n\n\n\nNote that the above occurrence indicators can be used to specify \nthe range of the number of times an element can appear. This not\nonly is useful to specify the number of times a child element \ncan appear in, say, a sequence, but also for specifying the \nnumber of times for example a sequence itself can occur. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncomplexContent defines extensions or restrictions on a complex type \n    that contains mixed content or elements only. \n\n\n\n\n\n\nxs:group and xs:attributeGroup cannot be extended or restricted in \n    the way xs:complexType or xs:simpleType can. They are purely to \n    group a number of items of data that are always used together.\n\n\n\n\n\n\nFinally, xs:documentation and xs:annotation allow for documentation\n    of the XML schema which is one of, if not the most, important parts\n    of defining XML schema. Again, if you haven't already, do take a \n    look at the \n    \n\n    Schema documentation\n.", 
            "title": "An Overview of XML and XSD"
        }, 
        {
            "location": "/BuildBattle/An_Overview_of_XML_and_XSD/#the-building-blocks-of-missions", 
            "text": "eXtensible Markup Language or XML provides for a software and hardware \n independent way to store and transmit data. Additionally, XML is a \n language that is designed for coming up with specialized markup \n languages. For example, one could come up with a language for \n genealogy, and define tags like  mother ,  father , \n  son , and  daughter . As a result of this ease of \n creating new languages, XML has been used in hundreds of document \n and markup language formats including MathML for specifying \n mathematical and scientific content, XHTML for extending HTML,\n the popular backbone language of the Internet, and Atom and RSS \n for delivering updates on regularly changing content.   Though XML is generally weak syntactically, there is a specification \n which should be followed for clarity and functionality. A thorough yet \n brief introduction to the key terminology is given in the \n   XML \n Wikipedia page  . Given below is an even briefer view on what will \n be important, especially in the context of Project Malm .    XML comprises of a string of characters. These characters may \n     generally be any \n      \n     Unicode character .    The characters making up an XML document are divided into markup \n     and content. These are different using simple syntactic rules.    As alluded to above in the example given previously, XML at its \n     core is built on tags, like many other Markup Languages. These \n     begin with   and end with  . More specifically, they come \n     in three flavors:   Start-tags like  section ,   End-tags like  /section , and   Empty-element tags like  line-break / .     A logical document component that either begins with a start-tag \n     and ends with a matching end-tag or consists of only an \n     empty-element tag. The characters between the start- and end-tags, \n     if any are the element's content. Examples are \n      Greeting Hello, World /Greeting ,  \n      line-break /line-break  and \n      line-break / .    Attributes are name/value pairs that exist within a start or \n     empty-element tag. In the example below the element  img  has \n     two attributes,  src  and  alt :  img src=\"proj_malmo.jpg\" alt=\"Project Malmo Image\" /  The above is an empty-element tag. Another example with start- and \n end-tags, where the only attribute is  number  with a value of 3,\n is:   step number=\"3\" Open the XML file. /step    An XML attribute can only have a single value and each attribute \n     can appear only once.    A processor or XML parser analyzes markup and passes structured \n     information to an application. The specification places \n     requirements on what an XML processor must do or not do, but the \n     application is outside of its scope.    Now, the last point about the processor and application is what leads us \nto XSD and JAXB, the next things to get an understanding of Missions in \nProject Malm .", 
            "title": "The Building Blocks of Missions"
        }, 
        {
            "location": "/BuildBattle/An_Overview_of_XML_and_XSD/#rules-for-the-building-blocks", 
            "text": "As described in the previous section, XML can be used to come up with \nnew markup languages. However, there is a question of how one does this \nand in particular of how the syntax is defined.   XML Schema Definitions or XSD formally describe \nelements in an XML document. Its purpose is to verify each piece of item\ncontent in an XML document, i.e., to parse an XML document using various \nSchemas (rules).   Without further ado, let's now take a look at the XSD files for Project\nMalm . Within the Project Malm  root folder, look for the \nSchemas folder. In there you will find (as of this tutorial's writing \nat least), 5 files with a .xsd extension. These are namely: Mission, \nMissionEnded, MissionHandlers, MissionInit and Types.   Feel free to go through the files and get an understanding of the \nstructure. The general format should be quite intuitive as XML is \ndesigned to be human readable while still having a well-defined syntax \nlike that of many programming languages.   To highlight a few points about the files and to direct your attention \nto some interesting properties of XSD, given below are somethings you \ncan try/have a read through with code snippets as appropriate for \nillustration purposes:     At the top of all of the files, there is the XML declaration which \n    specifies the version of XML to use and the character encoding to \n    use.      Just below the XML declaration, is the root element which is \n    required for XSD documents. This root element importantly contains\n    information about namespaces which are a common programming language\n    concept that prevents name conflicts (eg., when an element is \n    defined in multiple separate schema files).  xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  indicates that \nthe elements and data types used in the schema come from the w3 \norganizations namespace. It also specifies that elements that come\nfrom this namespace should be prefixed with xs.  The value of a targetNamespace,  http://ProjectMalmo.microsoft.com  is simply a unique \nidentifier, typically a company's project URL, that indicates \nthe elements defined by this schema come from the URL specified.  The default namespace is set to the same URL as the targetNamespace\nusing the  xmlns  attribute.  Setting elementFormDefault to qualified indicates that any elements\ndefined in the Schema must be qualified, i.e, be associated with a \nnamespace, when used in an XML document.    XML Schema have a lot of built-in data types including:\n     xs:string , \n     xs:decimal , \n     xs:integer , \n     xs:boolean , \n     xs:date , \n     xs:time .    A  Simple Element \n    is an XML element that contains text of one of the types included in \n    XSD or it can be a custom type. It cannot contain any other elements\n    or attributes. The syntax for defining a simple element is as\n    follows:  xs:element name=\"xxx\" type=\"yyy\" /    An  \n    Attribute  is very similar to a simple element. Simple elements\n    cannot have attributes. The syntax for defining an attribute is \n     xs:attribute name=\"xxx\" type=\"yyy\" /    A  simpleType  \n    element defines a simple type and specifies the \n    constraints and information about the values of attributes or \n    text-only elements. For examples, see Types.xsd where enumerations\n    are used for definitions of simpleTypes like Colour and BlockType. \n    In particular, note the use of xs:restriction to restrict the values\n    the simpleType can take as well as to define the base type which the \n    simpleType takes, such as xs:string.    A  Complex Element \n    contains other element and/or attributes. There \n    are four types based on the contents: \n     empty elements , \n     only other elements , \n     only text ,\n     and a mixture of other elements and text .     Complex Elements often make use of complexTypes as well as \n     \n    order and occurence indicators .     Order Indicators    The  all  indicator specifies that child elements can \nappear in any order, and that each child must occur only once.  The  choice  indicator specifies that only one of a list \nof children elements can be present.  The  sequence  indicator specifies that the child elements\nmust appear in a specific order.      Occurrence Indicators    The  minOccurs  indicator specifies the minimum number of \ntimes an element can occur and the  maxOccurs  indicator\nspecifies the maximum number of times an element can occur.     Note that the above occurrence indicators can be used to specify \nthe range of the number of times an element can appear. This not\nonly is useful to specify the number of times a child element \ncan appear in, say, a sequence, but also for specifying the \nnumber of times for example a sequence itself can occur.         complexContent defines extensions or restrictions on a complex type \n    that contains mixed content or elements only.     xs:group and xs:attributeGroup cannot be extended or restricted in \n    the way xs:complexType or xs:simpleType can. They are purely to \n    group a number of items of data that are always used together.    Finally, xs:documentation and xs:annotation allow for documentation\n    of the XML schema which is one of, if not the most, important parts\n    of defining XML schema. Again, if you haven't already, do take a \n    look at the \n     \n    Schema documentation .", 
            "title": "Rules for the Building Blocks"
        }, 
        {
            "location": "/BuildBattle/Defining_New_Schema/", 
            "text": "Mission Structure\n\n\nTake a look at the Mission.xsd in the Schemas folder of the \n root directory where Malm\n is installed. In there you will find \n Schema definitions for elements that form the overall structure of \n Missions. The general structure of a Mission XML can be inferred \n from there and from the tutorial code examples provided as such: \n\n\n    \nMission\n \n    \nAbout\n\n        \nSummary\nA Summary of the Mission\n/Summary\n\n        \nDescription\nA more detailed Description of the Mission\n/Description\n\n    \n/About\n\n    \nModSettings\n\n        \nMsPerTick\n50\n/MsPerTick\n\n        \nPrioritiseOffscreenRendering\nfalse\n/PrioritiseOffscreenRendering\n\n    \n/ModSettings\n \n    \nServerSection\n \n        \nServerInitialConditions\n\n            \nTime\n \n                \nStartTime\n1000\n/StartTime\n\n                \nAllowPassageOfTime\nfalse\n/AllowPassageOfTime\n\n            \n/Time\n\n            \nWeather\nclear\n/Weather\n\n            \nAllowSpawning\nfalse\n/AllowSpawning\n\n        \n/ServerInitialConditions\n\n        \nServerHandlers\n\n            \n!-- One of the following: \n\n                \nFlatWorldGenerator\n, \nFileWorldGenerator\n and \n                \nDefaultWorldGenerator\n\n                    ...\n                \n/ChosenWorldGenerator\n \n\n            --\n \n\n            \n!-- Some number of the following: \n\n                 \nDrawingDecorator\n, \nMazeDecorator\n, \n                 \nClassroomDecorator\n and \nSnakeDecorator\n\n                    ...\n                 \n/ChosenDecorator\n \n            --\n\n\n            \n!-- Some number of the following: \n\n                 \nServerQuitFromTimeUp\n and \n                 \nServerQuitWhenAnyAgentFinishes\n\n                    ...\n                 \n/ChosenQuitProducer\n  \n            --\n\n        \n/ServerHandlers\n\n    \n/ServerSection\n\n    \nAgentSection\n \n        \n!-- Some number of the following. \n             Note: AgentMissionHandlers are defined as a large xs:group in Mission.xsd\n                   These include: Observation Producers, Reward Handlers, Command Handlers, \n                                  and Agent Quit Producers  \n\n             \nAnAgentMissionHandler\n \n                ...\n             \n/TheAgentMissionHandler\n\n\n         --\n\n    \n/AgentSection\n\n  \n/Mission\n\n\n\n\n\nHopefully the above gives a good representation of what Missions look \nlike in Malm\n. Wherever possible, common sensible values have been \nreplaced such as for the Weather and StartTime. XML comments are \ndefined using \n!--\n and \n--\n with the contents within. \nThe comments above talk about what is to be in place of the comments \nin the given regions of the XML document. \n\n\nMission Handlers\n\n\nThis tutorial is focused on creating a new task, the Build Battle Task, \nand specifically for that we need a new Agent Mission Handler and in \nparticular a Reward Handler.\n\n\nNow, we will add our first line of code! Scroll to the \nxs:group\n named \n\nAgentMissionHandlers\n in the \nMission.xsd\n file. There should be a section \nof code with Reward Handlers. Add an element at the end of the section \nwith \nref\n set to \nRewardForStructureCopying\n and \nminOccurs\n set to \n0\n. \n\n\nAs we have talked about in the previous section, \nminOccurs\n is an \noccurrence indicator that specifies the minimum number of times an \nelement needs to appear (in this case in the all section of the group). \nThe ref attribute references an element that is declared elsewhere, \nwhich may or may not be in the same schema document. Take a look at the\ntop of the \nMission.xsd\n file. There you will see some xs:includes. We \nwill be writing the schema for the \nRewardForStructureCopying\n element in \n\nMissionHandler.xsd\n where all the other RewardHandlers and indeed \n(Agent)MissionHandlers are defined.\n\n\nAfter completing the above, you should have something like what is shown\nbelow:\n\n\n    \nxs:element ref=\nRewardForTouchingBlockType\n minOccurs=\n0\n /\n\n    \nxs:element ref=\nRewardForSendingCommand\n minOccurs=\n0\n /\n\n    \nxs:element ref=\nRewardForCollectingItem\n minOccurs=\n0\n /\n\n    \nxs:element ref=\nRewardForDiscardingItem\n minOccurs=\n0\n /\n\n    \nxs:element ref=\nRewardForReachingPosition\n minOccurs=\n0\n/\n\n    \nxs:element ref=\nRewardForMissionEnd\n minOccurs=\n0\n/\n\n    \nxs:element ref=\nRewardForStructureCopying\n minOccurs=\n0\n/\n\n\n\n\n\nNow, let us write the XML Schema Definition for \n\nRewardForStructureCopying\n. First, we open \n\nMissionHandler.xsd\n. Now, scroll down to the section just after \nthe comment which contains the phrase \"REWARD PRODUCERS.\"\n\n\nTo get an idea of what we will be adding first, take a look at the \nsimpleType definition \nBehavior\n:\n\n\nxs:simpleType name=\nBehaviour\n\n    \nxs:restriction base=\nxs:string\n\n      \nxs:enumeration value=\nonceOnly\n /\n\n      \nxs:enumeration value=\noncePerBlock\n /\n\n      \nxs:enumeration value=\noncePerTimeSpan\n /\n\n      \nxs:enumeration value=\nconstant\n /\n\n    \n/xs:restriction\n\n  \n/xs:simpleType\n\n\n\n\n\nAs can be seen above, Behavior is a simpleType that restricts a string \nto take one of four possible values (an enumeration with four possible\nvalues.) Functionally, if one looks at the naming and the Java files\nassociated with this Schema, Behavior specifies what is commonly \nknown in reinforcement learning as reward density.\n\n\nAs the names imply: onceOnly signifies that an agent will receive a \nreward once only, oncePerBlock signifies that an agent \nwill receive rewards once per block, oncePerTimeSpan specifies that \na reward is received only once in some time span, and finally, consant \nsignifies that a reward is constantly given. \n\n\nNow, the above explanations might seem a little vague, but it should do\nfor what we are going to add. \nRewardDensityForBuildAndBreak\n is \ntype very similar to \nBehavior\n in that it is also a reward density \ntype. Ideally we should reuse types if at all possible, however; just to \nillustrate the definitions of types in XSD as well as make a more \nfunctional and meaning type for the particular task we are creating, \nwe define this new type. Go ahead and add the following code snippet\nright after the last Schema definition in the Reward Producers section.\n\n\n  \nxs:simpleType name=\nRewardDensityForBuildAndBreak\n\n    \nxs:restriction base=\nxs:string\n\n      \nxs:enumeration value=\nPER_BLOCK\n/\n\n      \nxs:enumeration value=\nACCUMULATED\n/\n\n      \nxs:enumeration value=\nMISSION_END\n/\n\n    \n/xs:restriction\n\n  \n/xs:simpleType\n\n\n\n\n\nThe above simpleType definition also uses an \nxs:restriction\n with\nthe type \nxs:string\n. It can take one of three values, \n\nPER_BLOCK\n which signifies that a reward is given per block placed\nor broken, \nACCUMULATED\n signifying some sort of reward \naccumulation and \nMISSION_END\n signifying that a reward is only \ngiven at a mission's end. Again, these may seem like vague description, \nbut they will become clear when we add the Minecraft Forge code.\n\n\nNow, in the Build Battle, we will be comparing a given area where the \nplayer (agent) is to construct a structure that is already built. A \nsimple way to define such areas is using a cuboid. Given that Minecraft\nis comprised of voxels (individual cubes), we can describe a cuboid \nusing just 2 block positions: a minimum and maximum that form a diagonal\nof the cuboid. Take a look at the definition of \nGrid\n and \n\nDrawCuboid\n in the same \nMissionHandler.xsd\n file. Both of them\nare indeed what we would like to some extent; however, we don't really\nneed to have a \nGrid\n that is named nor do we need to specify block \ntypes and other block properties which the DrawCuboid requires. We thus\ncan define another type, namely \nUnnamedGridDefinition\n. \n\n\n  \nxs:complexType name=\nUnnamedGridDefinition\n\n    \nxs:sequence\n\n      \nxs:element name=\nmin\n type=\nPos\n /\n\n      \nxs:element name=\nmax\n type=\nPos\n /\n\n    \n/xs:sequence\n\n  \n/xs:complexType\n\n\n\n\n\nNote that the above type is complex and consists of a sequence with \ntwo elements, a \nPos\n named \nmin\n and a \nPos\n named \nmax\n\nwhere \nPos\n is on closer inspection (in the same \nMissionHandler.xsd\n file once again),\na 3-tuple defining x, y and z coordinates. Importantly, it should also \nbe said that \nxs:sequence\n tags by default use a \nminOccurs\n and\n\nmaxOccurs\n of 1 thus required all \nUnnamedGridDefinition\n to \nhave both a \nmax\n and \nmin\n.\n\n\nLast, but certainly not least, we define the actual \nRewardForStructureCopying\n\nSchema. It will take two \nUnnamedGridDefinition\ns defining the \nplayer structure bounds and built or goal structure bounds that are \nto be compared. Also, it will take two \nDrawBlockBasedObjectType\ns\nthat allow for providing visual feedback to agents and choosing the \nblock properties to use when blocks are switched for visual feedback. \nFor example, if the player places a block outside the player structure\nboundary, upon block placement the type of the block could change to \nredstone (giving the block a red appearance) along with a negative \nreward. Finally, we have a \nRewardDensityForBuildAndBreak\n also. \nThis gives the following code.\n\n\n  \nxs:element name=\nRewardForStructureCopying\n\n    \nxs:complexType\n\n      \nxs:sequence\n\n        \nxs:element name=\nPlayerStructureBounds\n type=\nUnnamedGridDefinition\n /\n\n        \nxs:element name=\nGoalStructureBounds\n type=\nUnnamedGridDefinition\n /\n\n        \nxs:element name=\nBlockTypeOnCorrectPlacement\n\n                    type=\nDrawBlockBasedObjectType\n nillable=\ntrue\n /\n\n        \nxs:element name=\nBlockTypeOnIncorrectPlacement\n\n                    type=\nDrawBlockBasedObjectType\n nillable=\ntrue\n /\n\n        \nxs:element name=\nRewardDensity\n type=\nRewardDensityForBuildAndBreak\n /\n\n      \n/xs:sequence\n\n      \nxs:attributeGroup ref=\nRewardProducerAttributes\n/\n\n    \n/xs:complexType\n\n  \n/xs:element\n\n\n\n\n\nThe inclusion of the attributeGroup \nRewardProducerAttributes\n is \nyet unexplained. Examine the other Reward Producers, you will in fact \nsee this attributeGroup in their definitions as well. The reason this \nis added is to allow for Reward Producers to share some attributes. In \nthis case, we'd like to give Rewards a dimension. The idea is to be able\nto associate certain types of rewards with a dimension. For example, \nwe might want to associate rewards for reaching goal locations with \nsay dimension 1 while rewards for defeating enemies with another \ndimension, giving a total of two dimensions and corresponding to \ntwo-dimensional vectors.\n\n\nUpon adding the above three code snippets to the end of the Reward \nProducers section, we are now ready to start writing the Forge side code\nand making changes to the Minecraft mod.\n\n\nAt this point, ensure that you have added the single line of code to \nyour \nMission.xsd\n file that adds a ref to \nRewardForStructureCopying\n as well\nas the above three code snippets in the given order right at the end\nof the Reward Producers section in the \nMissionHandlers.xsd\n file.\n\n\nTo test if everything is working right, try rebuilding the platform and \nin particular, try running the gradle task JAXB by executing: \n\n\n\n\nWindows: \ngradlew jaxb\n\n\nLinux/MacOS: \n./gradlew jaxb\n\n\n\n\nThe above will perform a task whereby necessary Java definitions of the \nschemas we just defined will be added. These will in fact be used \nshortly.", 
            "title": "Defining New Schema"
        }, 
        {
            "location": "/BuildBattle/Defining_New_Schema/#mission-structure", 
            "text": "Take a look at the Mission.xsd in the Schemas folder of the \n root directory where Malm  is installed. In there you will find \n Schema definitions for elements that form the overall structure of \n Missions. The general structure of a Mission XML can be inferred \n from there and from the tutorial code examples provided as such:        Mission  \n     About \n         Summary A Summary of the Mission /Summary \n         Description A more detailed Description of the Mission /Description \n     /About \n     ModSettings \n         MsPerTick 50 /MsPerTick \n         PrioritiseOffscreenRendering false /PrioritiseOffscreenRendering \n     /ModSettings  \n     ServerSection  \n         ServerInitialConditions \n             Time  \n                 StartTime 1000 /StartTime \n                 AllowPassageOfTime false /AllowPassageOfTime \n             /Time \n             Weather clear /Weather \n             AllowSpawning false /AllowSpawning \n         /ServerInitialConditions \n         ServerHandlers \n             !-- One of the following: \n\n                 FlatWorldGenerator ,  FileWorldGenerator  and \n                 DefaultWorldGenerator \n                    ...\n                 /ChosenWorldGenerator  \n\n            --  \n\n             !-- Some number of the following: \n\n                  DrawingDecorator ,  MazeDecorator , \n                  ClassroomDecorator  and  SnakeDecorator \n                    ...\n                  /ChosenDecorator  \n            -- \n\n             !-- Some number of the following: \n\n                  ServerQuitFromTimeUp  and \n                  ServerQuitWhenAnyAgentFinishes \n                    ...\n                  /ChosenQuitProducer   \n            -- \n         /ServerHandlers \n     /ServerSection \n     AgentSection  \n         !-- Some number of the following. \n             Note: AgentMissionHandlers are defined as a large xs:group in Mission.xsd\n                   These include: Observation Producers, Reward Handlers, Command Handlers, \n                                  and Agent Quit Producers  \n\n              AnAgentMissionHandler  \n                ...\n              /TheAgentMissionHandler \n\n         -- \n     /AgentSection \n   /Mission   Hopefully the above gives a good representation of what Missions look \nlike in Malm . Wherever possible, common sensible values have been \nreplaced such as for the Weather and StartTime. XML comments are \ndefined using  !--  and  --  with the contents within. \nThe comments above talk about what is to be in place of the comments \nin the given regions of the XML document.", 
            "title": "Mission Structure"
        }, 
        {
            "location": "/BuildBattle/Defining_New_Schema/#mission-handlers", 
            "text": "This tutorial is focused on creating a new task, the Build Battle Task, \nand specifically for that we need a new Agent Mission Handler and in \nparticular a Reward Handler.  Now, we will add our first line of code! Scroll to the  xs:group  named  AgentMissionHandlers  in the  Mission.xsd  file. There should be a section \nof code with Reward Handlers. Add an element at the end of the section \nwith  ref  set to  RewardForStructureCopying  and  minOccurs  set to  0 .   As we have talked about in the previous section,  minOccurs  is an \noccurrence indicator that specifies the minimum number of times an \nelement needs to appear (in this case in the all section of the group). \nThe ref attribute references an element that is declared elsewhere, \nwhich may or may not be in the same schema document. Take a look at the\ntop of the  Mission.xsd  file. There you will see some xs:includes. We \nwill be writing the schema for the  RewardForStructureCopying  element in  MissionHandler.xsd  where all the other RewardHandlers and indeed \n(Agent)MissionHandlers are defined.  After completing the above, you should have something like what is shown\nbelow:       xs:element ref= RewardForTouchingBlockType  minOccurs= 0  / \n     xs:element ref= RewardForSendingCommand  minOccurs= 0  / \n     xs:element ref= RewardForCollectingItem  minOccurs= 0  / \n     xs:element ref= RewardForDiscardingItem  minOccurs= 0  / \n     xs:element ref= RewardForReachingPosition  minOccurs= 0 / \n     xs:element ref= RewardForMissionEnd  minOccurs= 0 / \n     xs:element ref= RewardForStructureCopying  minOccurs= 0 /   Now, let us write the XML Schema Definition for  RewardForStructureCopying . First, we open  MissionHandler.xsd . Now, scroll down to the section just after \nthe comment which contains the phrase \"REWARD PRODUCERS.\"  To get an idea of what we will be adding first, take a look at the \nsimpleType definition  Behavior :  xs:simpleType name= Behaviour \n     xs:restriction base= xs:string \n       xs:enumeration value= onceOnly  / \n       xs:enumeration value= oncePerBlock  / \n       xs:enumeration value= oncePerTimeSpan  / \n       xs:enumeration value= constant  / \n     /xs:restriction \n   /xs:simpleType   As can be seen above, Behavior is a simpleType that restricts a string \nto take one of four possible values (an enumeration with four possible\nvalues.) Functionally, if one looks at the naming and the Java files\nassociated with this Schema, Behavior specifies what is commonly \nknown in reinforcement learning as reward density.  As the names imply: onceOnly signifies that an agent will receive a \nreward once only, oncePerBlock signifies that an agent \nwill receive rewards once per block, oncePerTimeSpan specifies that \na reward is received only once in some time span, and finally, consant \nsignifies that a reward is constantly given.   Now, the above explanations might seem a little vague, but it should do\nfor what we are going to add.  RewardDensityForBuildAndBreak  is \ntype very similar to  Behavior  in that it is also a reward density \ntype. Ideally we should reuse types if at all possible, however; just to \nillustrate the definitions of types in XSD as well as make a more \nfunctional and meaning type for the particular task we are creating, \nwe define this new type. Go ahead and add the following code snippet\nright after the last Schema definition in the Reward Producers section.     xs:simpleType name= RewardDensityForBuildAndBreak \n     xs:restriction base= xs:string \n       xs:enumeration value= PER_BLOCK / \n       xs:enumeration value= ACCUMULATED / \n       xs:enumeration value= MISSION_END / \n     /xs:restriction \n   /xs:simpleType   The above simpleType definition also uses an  xs:restriction  with\nthe type  xs:string . It can take one of three values,  PER_BLOCK  which signifies that a reward is given per block placed\nor broken,  ACCUMULATED  signifying some sort of reward \naccumulation and  MISSION_END  signifying that a reward is only \ngiven at a mission's end. Again, these may seem like vague description, \nbut they will become clear when we add the Minecraft Forge code.  Now, in the Build Battle, we will be comparing a given area where the \nplayer (agent) is to construct a structure that is already built. A \nsimple way to define such areas is using a cuboid. Given that Minecraft\nis comprised of voxels (individual cubes), we can describe a cuboid \nusing just 2 block positions: a minimum and maximum that form a diagonal\nof the cuboid. Take a look at the definition of  Grid  and  DrawCuboid  in the same  MissionHandler.xsd  file. Both of them\nare indeed what we would like to some extent; however, we don't really\nneed to have a  Grid  that is named nor do we need to specify block \ntypes and other block properties which the DrawCuboid requires. We thus\ncan define another type, namely  UnnamedGridDefinition .      xs:complexType name= UnnamedGridDefinition \n     xs:sequence \n       xs:element name= min  type= Pos  / \n       xs:element name= max  type= Pos  / \n     /xs:sequence \n   /xs:complexType   Note that the above type is complex and consists of a sequence with \ntwo elements, a  Pos  named  min  and a  Pos  named  max \nwhere  Pos  is on closer inspection (in the same  MissionHandler.xsd  file once again),\na 3-tuple defining x, y and z coordinates. Importantly, it should also \nbe said that  xs:sequence  tags by default use a  minOccurs  and maxOccurs  of 1 thus required all  UnnamedGridDefinition  to \nhave both a  max  and  min .  Last, but certainly not least, we define the actual  RewardForStructureCopying \nSchema. It will take two  UnnamedGridDefinition s defining the \nplayer structure bounds and built or goal structure bounds that are \nto be compared. Also, it will take two  DrawBlockBasedObjectType s\nthat allow for providing visual feedback to agents and choosing the \nblock properties to use when blocks are switched for visual feedback. \nFor example, if the player places a block outside the player structure\nboundary, upon block placement the type of the block could change to \nredstone (giving the block a red appearance) along with a negative \nreward. Finally, we have a  RewardDensityForBuildAndBreak  also. \nThis gives the following code.     xs:element name= RewardForStructureCopying \n     xs:complexType \n       xs:sequence \n         xs:element name= PlayerStructureBounds  type= UnnamedGridDefinition  / \n         xs:element name= GoalStructureBounds  type= UnnamedGridDefinition  / \n         xs:element name= BlockTypeOnCorrectPlacement \n                    type= DrawBlockBasedObjectType  nillable= true  / \n         xs:element name= BlockTypeOnIncorrectPlacement \n                    type= DrawBlockBasedObjectType  nillable= true  / \n         xs:element name= RewardDensity  type= RewardDensityForBuildAndBreak  / \n       /xs:sequence \n       xs:attributeGroup ref= RewardProducerAttributes / \n     /xs:complexType \n   /xs:element   The inclusion of the attributeGroup  RewardProducerAttributes  is \nyet unexplained. Examine the other Reward Producers, you will in fact \nsee this attributeGroup in their definitions as well. The reason this \nis added is to allow for Reward Producers to share some attributes. In \nthis case, we'd like to give Rewards a dimension. The idea is to be able\nto associate certain types of rewards with a dimension. For example, \nwe might want to associate rewards for reaching goal locations with \nsay dimension 1 while rewards for defeating enemies with another \ndimension, giving a total of two dimensions and corresponding to \ntwo-dimensional vectors.  Upon adding the above three code snippets to the end of the Reward \nProducers section, we are now ready to start writing the Forge side code\nand making changes to the Minecraft mod.  At this point, ensure that you have added the single line of code to \nyour  Mission.xsd  file that adds a ref to  RewardForStructureCopying  as well\nas the above three code snippets in the given order right at the end\nof the Reward Producers section in the  MissionHandlers.xsd  file.  To test if everything is working right, try rebuilding the platform and \nin particular, try running the gradle task JAXB by executing:    Windows:  gradlew jaxb  Linux/MacOS:  ./gradlew jaxb   The above will perform a task whereby necessary Java definitions of the \nschemas we just defined will be added. These will in fact be used \nshortly.", 
            "title": "Mission Handlers"
        }, 
        {
            "location": "/BuildBattle/Java_and_MinecraftForge/", 
            "text": "Java\n\n\nJava is a programming language that has become ubiquitous given its \nability to be used in many different hardware and software configurations\nthrough the Java Virtual Machine (JVM). It is quite similar in syntax \nto other strongly typed languages and compiled like C++. Given that this\ntutorial is aimed at learning about how to create a Project Malm\n \ntask and not a Java tutorial, should you be unfamiliar with Java \nor have never used Java before, it might be a good idea to go through \nsome Java resources: \nTutorials Point\n, \n\nJava Docs at Oracle\n, \n\nMinecraft Gamepedia Helpful Links for Creating Mods\n.\n\n\nMinecraft Forge\n\n\nAs alluded to above, Minecraft is written in Java and in fact uses the LightWeight Java Game Library. \nThus, to be able to able to create mods, it is a good idea to use \nJava itself. MinecraftForge, commonly known simply as Forge, is one \nsuch modding platform which uses Java that is quite mature and has been used for many \nMinecraft mods. At it's core, Forge provides access to the state of the \nMinecraft world, and entities like players, enemies, villagers, and \nthe weather. Additionally, Event Handlers provide hooks for getting \naccess into events like block place and break events which\nwe will be using.\n\n\nThere is not much thorough and up-to-date documentation on Forge. This \nis one reason using an IDE helps a lot since being able to go through \nthe Minecraft and Forge libraries itself serves as quite a good reference. \nThat said, many of the functions and arguments are \"obfuscated.\" \nFor example, you might see a function like \nfunc_152917_b(String p_152917_1_)\n.\nThis is generally the case for methods and parameters deep and internal to\nMinecraft. For many of these, you can find more information and possibly \nthe true name for the method and arguments on an Internet Relay Chat website, \n\nEsperNet\n, in the #MCPBot chatroom. \n\n\nApart from the above, there are indeed many resources and websites; however, \nas stated before, proceed with caution when using such resources as they \nmay be outdated. Here are some that can be very useful: \n\n\n\n\nMinecraft Forge Tutorial Wiki\n\n\nMinecraft Forge Forums\n\n\nA Complete list of all Forge Events available\n\n\nGrey Minecraft Coder's Modder Guide\n\n\nMinecraft Modding Tutorials by _Bedrock_Miner_\n\n\nJabelar's Minecraft Forge Modding Tutorials\n\n\nWuppy29 Minecraft Modding and Java Tutorials and Torubleshooting\n\n\nGitHub repo with Forge Tutorials and links to corresponding MinecraftForge Forums posts\n\n\nPlanet Minecraft Forums\n\n\nBytecode and ASM manipulation guide in a MinecraftForge forum post\n\n\nMazetar Modding Tutorial Databse\n\n\nMinecraftForge forum poast about client/server communication and threading\n\n\n\n\nIn the next section, we will begin writing the Forge side code. The steps will be presented in a manner much like the XSD instruction given before. \nSo, a deep understanding of Forge or Java isn't really required. That said, have a look around some of the resources \npresented above and take a look at the Project Malm\n code in the IDE you have installed.", 
            "title": "Java and MinecraftForge"
        }, 
        {
            "location": "/BuildBattle/Java_and_MinecraftForge/#java", 
            "text": "Java is a programming language that has become ubiquitous given its \nability to be used in many different hardware and software configurations\nthrough the Java Virtual Machine (JVM). It is quite similar in syntax \nto other strongly typed languages and compiled like C++. Given that this\ntutorial is aimed at learning about how to create a Project Malm  \ntask and not a Java tutorial, should you be unfamiliar with Java \nor have never used Java before, it might be a good idea to go through \nsome Java resources:  Tutorials Point ,  Java Docs at Oracle ,  Minecraft Gamepedia Helpful Links for Creating Mods .", 
            "title": "Java"
        }, 
        {
            "location": "/BuildBattle/Java_and_MinecraftForge/#minecraft-forge", 
            "text": "As alluded to above, Minecraft is written in Java and in fact uses the LightWeight Java Game Library. \nThus, to be able to able to create mods, it is a good idea to use \nJava itself. MinecraftForge, commonly known simply as Forge, is one \nsuch modding platform which uses Java that is quite mature and has been used for many \nMinecraft mods. At it's core, Forge provides access to the state of the \nMinecraft world, and entities like players, enemies, villagers, and \nthe weather. Additionally, Event Handlers provide hooks for getting \naccess into events like block place and break events which\nwe will be using.  There is not much thorough and up-to-date documentation on Forge. This \nis one reason using an IDE helps a lot since being able to go through \nthe Minecraft and Forge libraries itself serves as quite a good reference. \nThat said, many of the functions and arguments are \"obfuscated.\" \nFor example, you might see a function like  func_152917_b(String p_152917_1_) .\nThis is generally the case for methods and parameters deep and internal to\nMinecraft. For many of these, you can find more information and possibly \nthe true name for the method and arguments on an Internet Relay Chat website,  EsperNet , in the #MCPBot chatroom.   Apart from the above, there are indeed many resources and websites; however, \nas stated before, proceed with caution when using such resources as they \nmay be outdated. Here are some that can be very useful:    Minecraft Forge Tutorial Wiki  Minecraft Forge Forums  A Complete list of all Forge Events available  Grey Minecraft Coder's Modder Guide  Minecraft Modding Tutorials by _Bedrock_Miner_  Jabelar's Minecraft Forge Modding Tutorials  Wuppy29 Minecraft Modding and Java Tutorials and Torubleshooting  GitHub repo with Forge Tutorials and links to corresponding MinecraftForge Forums posts  Planet Minecraft Forums  Bytecode and ASM manipulation guide in a MinecraftForge forum post  Mazetar Modding Tutorial Databse  MinecraftForge forum poast about client/server communication and threading   In the next section, we will begin writing the Forge side code. The steps will be presented in a manner much like the XSD instruction given before. \nSo, a deep understanding of Forge or Java isn't really required. That said, have a look around some of the resources \npresented above and take a look at the Project Malm  code in the IDE you have installed.", 
            "title": "Minecraft Forge"
        }, 
        {
            "location": "/BuildBattle/Creating_Schema_Implementations/", 
            "text": "Adding a Java Class\n\n\nIf you have not already, open the Project Malm\n project in your \nIDE. I use IntelliJ, and so will be presenting the steps for it, but the \nsteps in Eclipse should be about the same. \n\n\nNow, we are going to add a new Java class. In IntelliJ, look for the \nfolder \nMissionHandlers\n. Then, right-click on the folder, \nselect \nNew\n and then \nJava Class\n. When a pop-up window opens,\ntype the name as \nRewardForStructureCopyingImplementation\n. \nThe name must be exactly this since the function \n\ncreateHandlerFromParams\n in the class \nMissionBehavior\n looks \nfor a class named \nRewardForStructureCopying\n (the Schema name) \nfollowed by \nImplementation\n. Try to verify this by opening the \n\nMissionBehavior\n class. To do so, you can use one of the many nifty \ntools IntelliJ and IDEs in general provide: Search. In IntelliJ, you \ncan click the shift button twice to bring up Search.\n\n\nSubclassing and Interfaces\n\n\nOpen the \nRewardForStructureConstruction\n class again. \nAt this point, have a look at the code for some of the other Reward \nHandlers under \nMissionHandlers\n. There are a few things\nthat are worth noting. Firstly, all of them extend or in other words \nsubclass\nHandlerBase\n (meaning some fields or functions are \ninherited from the superclass \nHandlerBase\n while others must be\nimplemented or \"overriden\" so as to change the functionality of some \nmethods). Also, all of the Reward Handlers implement \n\nIRewardProducer\n, an interface. This means that all the Reward \nHandlers follow some protocol and can be treated in the same manner \ngiven that they implement the methods necessary according to the \nInterface.\n\n\nWith the above said, change the \nRewardForStructureCopying\n class \nso that you make the two changes. This means that you will now have \nsomething like this: \n\n\npublic class RewardForStructureCopyingImplementation extends HandlerBase implements IRewardProducer{\n\n}\n\n\n\n\nGenerate Superclass and Interface functions\n\n\nYou might now notice that the IDE complains about some errors. These\nerrors are due to the fact that we have not yet implemented some \nfunctions we have guaranteed to based on our class definition (in \nparticular the extends and implements bit).\n\n\nWe will now add some functions from the classes we have inherited or \nthe interfaces we have said we will implement. In IntelliJ, right-click\nanywhere inside the brackets enclosing the class definitions and fields.\nNow, choose \nGenerate...\n followed by \nOverride Methods...\n. \nAlternatively, place your cursor between the brackets and hit \n\nCtrl + o\n. Now, choose \n\nparseParameters(params:Object):boolean\n under \n\ncom.microsoft.Malmo.MissionHandlers.HandlerBase\n. Next, \nhold the \nCtrl\n key and without leaving the key select \n\ngetReward(missionInit:MissionInit):float\n, \n\nprepare(missionInit:MissionInit):void\n and \n\ncleanup():void\n, all of which are under \n\ncom.microsoft.Malmo.MissionHandlerInterfaces.IRewardProducer\n. \nYou may leave the \nCtrl\n key and now using the using the mouse, \nif they are not already checked, \nclick on \nCopy JavaDoc\n and \nInsert @Override\n. \n\n\nNote: the \nCtrl\n key may not work if you are on a Mac for example. \n      In this case, just choose the above methods one by one by \n      repeating the steps.\n\n\nYou should now have something like this: \n\n\npublic class RewardForStructureConstructionImplementation extends HandlerBase implements IRewardProducer {\n    /**\n     * Attempt to parse the given object as a set of parameters for this handler.\n     *\n     * @param params the parameter block to parse\n     * @return true if the object made sense for this handler; false otherwise.\n     */\n    @Override\n    public boolean parseParameters(Object params) {\n        return super.parseParameters(params);\n    }\n\n    /**\n     * Get the reward value for the current Minecraft state.\n     *\n     * @param missionInit the MissionInit object for the currently running mission, \n     *        which may contain parameters for the reward requirements.\n     * @return a float determining the current reward signal for the learning agent\n     */\n    @Override\n    public float getReward(MissionInit missionInit) {\n        return 0;\n    }\n\n    /**\n     * Called once before the mission starts - use for any necessary initialisation.\n     *\n     * @param missionInit\n     */\n    @Override\n    public void prepare(MissionInit missionInit) {\n\n    }\n\n    /**\n     * Called once after the mission ends - use for any necessary cleanup.\n     */\n    @Override\n    public void cleanup() {\n\n    }\n}", 
            "title": "Creating Schema Implementations"
        }, 
        {
            "location": "/BuildBattle/Creating_Schema_Implementations/#adding-a-java-class", 
            "text": "If you have not already, open the Project Malm  project in your \nIDE. I use IntelliJ, and so will be presenting the steps for it, but the \nsteps in Eclipse should be about the same.   Now, we are going to add a new Java class. In IntelliJ, look for the \nfolder  MissionHandlers . Then, right-click on the folder, \nselect  New  and then  Java Class . When a pop-up window opens,\ntype the name as  RewardForStructureCopyingImplementation . \nThe name must be exactly this since the function  createHandlerFromParams  in the class  MissionBehavior  looks \nfor a class named  RewardForStructureCopying  (the Schema name) \nfollowed by  Implementation . Try to verify this by opening the  MissionBehavior  class. To do so, you can use one of the many nifty \ntools IntelliJ and IDEs in general provide: Search. In IntelliJ, you \ncan click the shift button twice to bring up Search.", 
            "title": "Adding a Java Class"
        }, 
        {
            "location": "/BuildBattle/Creating_Schema_Implementations/#subclassing-and-interfaces", 
            "text": "Open the  RewardForStructureConstruction  class again. \nAt this point, have a look at the code for some of the other Reward \nHandlers under  MissionHandlers . There are a few things\nthat are worth noting. Firstly, all of them extend or in other words \nsubclass HandlerBase  (meaning some fields or functions are \ninherited from the superclass  HandlerBase  while others must be\nimplemented or \"overriden\" so as to change the functionality of some \nmethods). Also, all of the Reward Handlers implement  IRewardProducer , an interface. This means that all the Reward \nHandlers follow some protocol and can be treated in the same manner \ngiven that they implement the methods necessary according to the \nInterface.  With the above said, change the  RewardForStructureCopying  class \nso that you make the two changes. This means that you will now have \nsomething like this:   public class RewardForStructureCopyingImplementation extends HandlerBase implements IRewardProducer{\n\n}", 
            "title": "Subclassing and Interfaces"
        }, 
        {
            "location": "/BuildBattle/Creating_Schema_Implementations/#generate-superclass-and-interface-functions", 
            "text": "You might now notice that the IDE complains about some errors. These\nerrors are due to the fact that we have not yet implemented some \nfunctions we have guaranteed to based on our class definition (in \nparticular the extends and implements bit).  We will now add some functions from the classes we have inherited or \nthe interfaces we have said we will implement. In IntelliJ, right-click\nanywhere inside the brackets enclosing the class definitions and fields.\nNow, choose  Generate...  followed by  Override Methods... . \nAlternatively, place your cursor between the brackets and hit  Ctrl + o . Now, choose  parseParameters(params:Object):boolean  under  com.microsoft.Malmo.MissionHandlers.HandlerBase . Next, \nhold the  Ctrl  key and without leaving the key select  getReward(missionInit:MissionInit):float ,  prepare(missionInit:MissionInit):void  and  cleanup():void , all of which are under  com.microsoft.Malmo.MissionHandlerInterfaces.IRewardProducer . \nYou may leave the  Ctrl  key and now using the using the mouse, \nif they are not already checked, \nclick on  Copy JavaDoc  and  Insert @Override .   Note: the  Ctrl  key may not work if you are on a Mac for example. \n      In this case, just choose the above methods one by one by \n      repeating the steps.  You should now have something like this:   public class RewardForStructureConstructionImplementation extends HandlerBase implements IRewardProducer {\n    /**\n     * Attempt to parse the given object as a set of parameters for this handler.\n     *\n     * @param params the parameter block to parse\n     * @return true if the object made sense for this handler; false otherwise.\n     */\n    @Override\n    public boolean parseParameters(Object params) {\n        return super.parseParameters(params);\n    }\n\n    /**\n     * Get the reward value for the current Minecraft state.\n     *\n     * @param missionInit the MissionInit object for the currently running mission, \n     *        which may contain parameters for the reward requirements.\n     * @return a float determining the current reward signal for the learning agent\n     */\n    @Override\n    public float getReward(MissionInit missionInit) {\n        return 0;\n    }\n\n    /**\n     * Called once before the mission starts - use for any necessary initialisation.\n     *\n     * @param missionInit\n     */\n    @Override\n    public void prepare(MissionInit missionInit) {\n\n    }\n\n    /**\n     * Called once after the mission ends - use for any necessary cleanup.\n     */\n    @Override\n    public void cleanup() {\n\n    }\n}", 
            "title": "Generate Superclass and Interface functions"
        }, 
        {
            "location": "/BuildBattle/Defining_Simple_Functions/", 
            "text": "Parsing Parameters\n\n\nTake a look at the \nparseParameters(Object params)\n function in \nthe various classes in \nMissionHandlers\n. This should give a good\nidea about what it is we are about to do.\n\n\nThe code we will add for the \nparseParameters\n function is given below. \nNote that we remove the code already within \nparseParameters\n which \nsimply calls a superclass method. This is not really what we would like. \nWe want to override the superclass method and change the return values.\n\n\n    @Override\n    public boolean parseParameters(Object params) {\n\n        if (params == null || !(params instanceof RewardForStructureCopying))\n            return false;\n\n        RewardForStructureCopying rscparams = (RewardForStructureCopying) params;\n\n        BlockPos minPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMin());\n        BlockPos maxPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMax());\n        BlockPos minGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMin());\n        BlockPos maxGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMax());\n\n        this.playerStructureAABB = new AxisAlignedBB(minPlayerStructurePos, maxPlayerStructurePos);\n        this.goalStructureAABB = new AxisAlignedBB(minGoalStructurePos, maxGoalStructurePos);\n\n        if(playerStructureAABB.intersectsWith(goalStructureAABB))\n        {\n            System.out.print(\nWarning! RewardForStructureCopying got player structure bounds\n + \n                             \n and goal structure bounds that intersect!\n +\n                             \n Undefined behavior can follow!\\n\n);\n        }\n\n        this.structureVolume = volumeOfAABB(playerStructureAABB);\n\n        if(this.structureVolume != volumeOfAABB(goalStructureAABB))\n        {\n            System.out.print(\nWarning! RewardForStructureCopying got player structure bounds\n + \n                             \n and goal structure bounds that have unequal volumes!\n + \n                             \n Undefined behavior can follow!\\n\n);\n\n        }\n\n        this.delta = new Vec3i(goalStructureAABB.minX - playerStructureAABB.minX,\n                goalStructureAABB.minY - playerStructureAABB.minY,\n                goalStructureAABB.minZ - playerStructureAABB.minZ);\n\n        this.rewardDensity = rscparams.getRewardDensity();\n\n        DrawBlockBasedObjectType blockBasedObjectType = rscparams.getBlockTypeOnCorrectPlacement();\n\n        this.blockTypeOnCorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        blockBasedObjectType = rscparams.getBlockTypeOnIncorrectPlacement();\n\n        this.blockTypeOnIncorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        this.dimension = rscparams.getDimension();\n\n        return true;\n    }\n\n\n\n\nThe first thing we do is check if the \nparams\n object is null or is\nnot of the Schema type we are expect, i.e., not of the type \nRewardForStructureCopying\n. \nIf either is the case, we return \nfalse\n presumably telling the caller of this \nfunction that the Schmea given is not something the Implementation was designed for.\n\n\nOn the other hand, if the \nparams\n object is indeed of type \n\nRewardForStructureCopying\n, we perform a cast from \nObject\n, \nJava's only class that has no superclass and from which all other classes\ninherit, to \nRewardForStructureCopying\n and set the instance to \na variance named \nrscparams\n following the convention of the other \nReward Handlers (rsc stands for Reward, Structure and copying resp.)\n\n\nOnce we have a \nRewardForStructureCopying\n instance, we can query \nit for the variables we'd like to store. \n\n\nFirstly, we get four \nBlockPos\n instances. This is the first Minecraft \ntype we are seeing! \nBlockPos\n is essentially an object that contains information \nabout a block's position or in other words contains data similar to a 3-tuple or 3-dimensional vector.\nNote the use of the method \nblockPosFromPos\n which is given below: \n\n\nprivate BlockPos blockPosFromPos(@Nonnull Pos pos) {\n    return new BlockPos(pos.getX().intValueExact(), \n                        pos.getY().intValueExact(), \n                        pos.getZ().intValueExact());\n}\n\n\n\n\nThe above method just returns a new \nBlockPos\n instance from \na \npos\n instance which JAXB seems to have created (recall that \nour \nUnnamedGridDefinition\n used a type defined in the Schema, \nnamely \nPos\n.) It turns out that \nPos\n comprises of \nBigDecimal\ns \nsince \nPos\n uses \nxs:decimal\ns. This is a nice type for \nperforming accurate and exact arithmetic operations; however, for \ncomparing two grids of the same volume, we will be comparing the blocks\nwithin the grid themselves and we don't really care for decimals or \nfloating point arithmetic. We can make do with integers. Thus, we \ncreate a new \nBlockPos\n with \nintValueExact()\n of the three \n\nBigDecimals\n. Finally, note the use of the annotation \n@NonNull\n\nwhich helps IDEs find places where \nblockPosFromPos\n might have been \ncalled with a ``null``` argument and raise an error for the user (even \nbefore compile-time).\n\n\nNext, we define two Axis Aligned Bounding Blocks which in essence are \nanalogous to \nUnnamedGridDefinition\ns, but hold block positions \nusing \nBlockPos\n' rather than \nPos\n'. We use these to \nimmediately perform a simple check: do the player structure and goal \nstructure intersect? If they do, we quit; else, we continue.\n\n\nWe now go on to find and ensure that the structure volumes of the two \nstructures are the same. This uses the following member function: \n\n\nprivate float volumeOfAABB(AxisAlignedBB axisAlignedBB) {\n    return (float) (axisAlignedBB.maxX - axisAlignedBB.minX + 1) *\n            (float) (axisAlignedBB.maxY - axisAlignedBB.minY + 1) *\n            (float) (axisAlignedBB.maxZ - axisAlignedBB.minZ + 1);\n}\n\n\n\n\nMoving on, we find \ndelta\n which is a 3-dimensional vector specifying\nthe vector to add to a particular block position in the player \nstructure to get the corresponding goal structure\nblock position. We will use this vector when we compare the two\nstructures. Continuing on, we store the Reward Density. \n\n\nThe \nBlockDrawingHelper\n class and \nMinecraftTypeHelper\n classes are definitely something you\nshould look at, these are used by the \nDrawingDecorators\n and are \nalso useful in parsing information of Schema like \nDrawBlockBasedObjectType\n\nto get \nIBlockState\ns, Minecraft's internal representation of Block\nStates. And so, penultimately, we get two \nIBlockStates\n \ncorresponding to Block States to use for the Correct Block Placement and \nIncorrect Block Placement cases. Finally, we store the dimension along \nwhich rewards for this instance of \nRewardForStructureCopying\n are \nto be sent.\n\n\nIf all of the above succeeds, we have completed parsing a \n\nRewardForStructureCopying\n Schema and can return \ntrue\n.\n\n\nPrepare and Cleanup\n\n\nAgain, taking a look at the other Mission Handlers, and, in particular, \nthe Reward Handlers, we see that in the \nprepare\n methods, we \nremove \nQuitCode\ns that are present in the \nMalmoMod\n properties\nand perform registration of the class. The latter step, registering a \nclass to the Minecraft Forge \nEVENT_BUS\n is crucial when we begin \nadding Event Handlers. Without it, the event handlers will not fire. \nNote that there is another bus for adding event handlers to, the\n\nFMLCommonHandler.bus()\n. To see when you need to register event \nhandlers to that bus, take a look at the Complete list of Forge Event \nHandlers, given as a resource for Minecraft Forge in the Java and \nMinecraftForge section. Thus, prepare is as follows: \n\n\n@Override\npublic void prepare(MissionInit missionInit) {\n    try\n    {\n        if (MalmoMod.getPropertiesForCurrentThread().containsKey(\nQuitCode\n))\n            MalmoMod.getPropertiesForCurrentThread().remove(\nQuitCode\n);\n    }\n    catch (Exception e)\n    {\n        System.out.println(\nFailed to get properties.\n);\n    }\n\n    MinecraftForge.EVENT_BUS.register(this);\n}\n\n\n\n\nCleanup is very simple in that the only thing we do is unregister the \nclass, like so: \n\n\n@Override\npublic void cleanup() {\n    MinecraftForge.EVENT_BUS.unregister(this);\n}\n\n\n\n\nThe end result of this section along with some member variables that \nwere not shown is as follows: \n\n\npublic class RewardForStructureConstructionImplementation extends HandlerBase implements IRewardProducer {\n    private AxisAlignedBB playerStructureAABB;\n    private AxisAlignedBB goalStructureAABB;\n\n    private Vec3i delta;\n    private float structureVolume;\n\n    private RewardDensityForBuildAndBreak rewardDensity;\n\n    private IBlockState blockTypeOnCorrectPlacement;\n    private IBlockState blockTypeOnIncorrectPlacement;\n\n    private int dimension;\n\n    /**\n     * Attempt to parse the given object as a set of parameters for this handler.\n     *\n     * @param params the parameter block to parse\n     * @return true if the object made sense for this handler; false otherwise.\n     */\n    @Override\n    public boolean parseParameters(Object params) {\n        if (params == null || !(params instanceof RewardForStructureCopying))\n            return false;\n\n        RewardForStructureCopying rscparams = (RewardForStructureCopying) params;\n\n        BlockPos minPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMin());\n        BlockPos maxPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMax());\n        BlockPos minGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMin());\n        BlockPos maxGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMax());\n\n        this.playerStructureAABB = new AxisAlignedBB(minPlayerStructurePos, maxPlayerStructurePos);\n        this.goalStructureAABB = new AxisAlignedBB(minGoalStructurePos, maxGoalStructurePos);\n\n        assert(!playerStructureAABB.intersectsWith(goalStructureAABB));\n\n        this.structureVolume = volumeOfAABB(playerStructureAABB);\n        assert(this.structureVolume == volumeOfAABB(goalStructureAABB));\n\n        this.delta = new Vec3i(goalStructureAABB.minX - playerStructureAABB.minX,\n                goalStructureAABB.minY - playerStructureAABB.minY,\n                goalStructureAABB.minZ - playerStructureAABB.minZ);\n\n        this.rewardDensity = rscparams.getRewardDensity();\n\n        DrawBlockBasedObjectType blockBasedObjectType = rscparams.getBlockTypeOnCorrectPlacement();\n\n        this.blockTypeOnCorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        blockBasedObjectType = rscparams.getBlockTypeOnIncorrectPlacement();\n\n        this.blockTypeOnIncorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        this.dimension = rscparams.getDimension();\n\n        return true;\n    }\n\n    private BlockPos blockPosFromPos(@Nonnull Pos pos) {\n        return new BlockPos(pos.getX().intValueExact(), pos.getY().intValueExact(), \n                            pos.getZ().intValueExact());\n    }\n\n    private float volumeOfAABB(AxisAlignedBB axisAlignedBB) {\n        return (float) (axisAlignedBB.maxX - axisAlignedBB.minX + 1) *\n                (float) (axisAlignedBB.maxY - axisAlignedBB.minY + 1) *\n                (float) (axisAlignedBB.maxZ - axisAlignedBB.minZ + 1);\n    }\n\n    /**\n     * Get the reward value for the current Minecraft state.\n     *\n     * @param missionInit the MissionInit object for the currently running mission, \n     *        which may contain parameters for the reward requirements.\n     * @return a float determining the current reward signal for the learning agent\n     */\n    @Override\n    public float getReward(MissionInit missionInit) {\n        return 0;\n    }\n\n    /**\n     * Called once before the mission starts - use for any necessary initialisation.\n     *\n     * @param missionInit\n     */\n    @Override\n    public void prepare(MissionInit missionInit) {\n        try\n        {\n            if (MalmoMod.getPropertiesForCurrentThread().containsKey(\nQuitCode\n))\n             MalmoMod.getPropertiesForCurrentThread().remove(\nQuitCode\n);\n        }\n        catch (Exception e)\n        {\n            System.out.println(\nFailed to get properties.\n);\n        }\n\n        MinecraftForge.EVENT_BUS.register(this);\n    }\n\n    /**\n     * Called once after the mission ends - use for any necessary cleanup.\n     */\n    @Override\n    public void cleanup() {\n        MinecraftForge.EVENT_BUS.unregister(this);\n    }\n}", 
            "title": "Defining Simple Functions"
        }, 
        {
            "location": "/BuildBattle/Defining_Simple_Functions/#parsing-parameters", 
            "text": "Take a look at the  parseParameters(Object params)  function in \nthe various classes in  MissionHandlers . This should give a good\nidea about what it is we are about to do.  The code we will add for the  parseParameters  function is given below. \nNote that we remove the code already within  parseParameters  which \nsimply calls a superclass method. This is not really what we would like. \nWe want to override the superclass method and change the return values.      @Override\n    public boolean parseParameters(Object params) {\n\n        if (params == null || !(params instanceof RewardForStructureCopying))\n            return false;\n\n        RewardForStructureCopying rscparams = (RewardForStructureCopying) params;\n\n        BlockPos minPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMin());\n        BlockPos maxPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMax());\n        BlockPos minGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMin());\n        BlockPos maxGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMax());\n\n        this.playerStructureAABB = new AxisAlignedBB(minPlayerStructurePos, maxPlayerStructurePos);\n        this.goalStructureAABB = new AxisAlignedBB(minGoalStructurePos, maxGoalStructurePos);\n\n        if(playerStructureAABB.intersectsWith(goalStructureAABB))\n        {\n            System.out.print( Warning! RewardForStructureCopying got player structure bounds  + \n                               and goal structure bounds that intersect!  +\n                               Undefined behavior can follow!\\n );\n        }\n\n        this.structureVolume = volumeOfAABB(playerStructureAABB);\n\n        if(this.structureVolume != volumeOfAABB(goalStructureAABB))\n        {\n            System.out.print( Warning! RewardForStructureCopying got player structure bounds  + \n                               and goal structure bounds that have unequal volumes!  + \n                               Undefined behavior can follow!\\n );\n\n        }\n\n        this.delta = new Vec3i(goalStructureAABB.minX - playerStructureAABB.minX,\n                goalStructureAABB.minY - playerStructureAABB.minY,\n                goalStructureAABB.minZ - playerStructureAABB.minZ);\n\n        this.rewardDensity = rscparams.getRewardDensity();\n\n        DrawBlockBasedObjectType blockBasedObjectType = rscparams.getBlockTypeOnCorrectPlacement();\n\n        this.blockTypeOnCorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        blockBasedObjectType = rscparams.getBlockTypeOnIncorrectPlacement();\n\n        this.blockTypeOnIncorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        this.dimension = rscparams.getDimension();\n\n        return true;\n    }  The first thing we do is check if the  params  object is null or is\nnot of the Schema type we are expect, i.e., not of the type  RewardForStructureCopying . \nIf either is the case, we return  false  presumably telling the caller of this \nfunction that the Schmea given is not something the Implementation was designed for.  On the other hand, if the  params  object is indeed of type  RewardForStructureCopying , we perform a cast from  Object , \nJava's only class that has no superclass and from which all other classes\ninherit, to  RewardForStructureCopying  and set the instance to \na variance named  rscparams  following the convention of the other \nReward Handlers (rsc stands for Reward, Structure and copying resp.)  Once we have a  RewardForStructureCopying  instance, we can query \nit for the variables we'd like to store.   Firstly, we get four  BlockPos  instances. This is the first Minecraft \ntype we are seeing!  BlockPos  is essentially an object that contains information \nabout a block's position or in other words contains data similar to a 3-tuple or 3-dimensional vector.\nNote the use of the method  blockPosFromPos  which is given below:   private BlockPos blockPosFromPos(@Nonnull Pos pos) {\n    return new BlockPos(pos.getX().intValueExact(), \n                        pos.getY().intValueExact(), \n                        pos.getZ().intValueExact());\n}  The above method just returns a new  BlockPos  instance from \na  pos  instance which JAXB seems to have created (recall that \nour  UnnamedGridDefinition  used a type defined in the Schema, \nnamely  Pos .) It turns out that  Pos  comprises of  BigDecimal s \nsince  Pos  uses  xs:decimal s. This is a nice type for \nperforming accurate and exact arithmetic operations; however, for \ncomparing two grids of the same volume, we will be comparing the blocks\nwithin the grid themselves and we don't really care for decimals or \nfloating point arithmetic. We can make do with integers. Thus, we \ncreate a new  BlockPos  with  intValueExact()  of the three  BigDecimals . Finally, note the use of the annotation  @NonNull \nwhich helps IDEs find places where  blockPosFromPos  might have been \ncalled with a ``null``` argument and raise an error for the user (even \nbefore compile-time).  Next, we define two Axis Aligned Bounding Blocks which in essence are \nanalogous to  UnnamedGridDefinition s, but hold block positions \nusing  BlockPos ' rather than  Pos '. We use these to \nimmediately perform a simple check: do the player structure and goal \nstructure intersect? If they do, we quit; else, we continue.  We now go on to find and ensure that the structure volumes of the two \nstructures are the same. This uses the following member function:   private float volumeOfAABB(AxisAlignedBB axisAlignedBB) {\n    return (float) (axisAlignedBB.maxX - axisAlignedBB.minX + 1) *\n            (float) (axisAlignedBB.maxY - axisAlignedBB.minY + 1) *\n            (float) (axisAlignedBB.maxZ - axisAlignedBB.minZ + 1);\n}  Moving on, we find  delta  which is a 3-dimensional vector specifying\nthe vector to add to a particular block position in the player \nstructure to get the corresponding goal structure\nblock position. We will use this vector when we compare the two\nstructures. Continuing on, we store the Reward Density.   The  BlockDrawingHelper  class and  MinecraftTypeHelper  classes are definitely something you\nshould look at, these are used by the  DrawingDecorators  and are \nalso useful in parsing information of Schema like  DrawBlockBasedObjectType \nto get  IBlockState s, Minecraft's internal representation of Block\nStates. And so, penultimately, we get two  IBlockStates  \ncorresponding to Block States to use for the Correct Block Placement and \nIncorrect Block Placement cases. Finally, we store the dimension along \nwhich rewards for this instance of  RewardForStructureCopying  are \nto be sent.  If all of the above succeeds, we have completed parsing a  RewardForStructureCopying  Schema and can return  true .", 
            "title": "Parsing Parameters"
        }, 
        {
            "location": "/BuildBattle/Defining_Simple_Functions/#prepare-and-cleanup", 
            "text": "Again, taking a look at the other Mission Handlers, and, in particular, \nthe Reward Handlers, we see that in the  prepare  methods, we \nremove  QuitCode s that are present in the  MalmoMod  properties\nand perform registration of the class. The latter step, registering a \nclass to the Minecraft Forge  EVENT_BUS  is crucial when we begin \nadding Event Handlers. Without it, the event handlers will not fire. \nNote that there is another bus for adding event handlers to, the FMLCommonHandler.bus() . To see when you need to register event \nhandlers to that bus, take a look at the Complete list of Forge Event \nHandlers, given as a resource for Minecraft Forge in the Java and \nMinecraftForge section. Thus, prepare is as follows:   @Override\npublic void prepare(MissionInit missionInit) {\n    try\n    {\n        if (MalmoMod.getPropertiesForCurrentThread().containsKey( QuitCode ))\n            MalmoMod.getPropertiesForCurrentThread().remove( QuitCode );\n    }\n    catch (Exception e)\n    {\n        System.out.println( Failed to get properties. );\n    }\n\n    MinecraftForge.EVENT_BUS.register(this);\n}  Cleanup is very simple in that the only thing we do is unregister the \nclass, like so:   @Override\npublic void cleanup() {\n    MinecraftForge.EVENT_BUS.unregister(this);\n}  The end result of this section along with some member variables that \nwere not shown is as follows:   public class RewardForStructureConstructionImplementation extends HandlerBase implements IRewardProducer {\n    private AxisAlignedBB playerStructureAABB;\n    private AxisAlignedBB goalStructureAABB;\n\n    private Vec3i delta;\n    private float structureVolume;\n\n    private RewardDensityForBuildAndBreak rewardDensity;\n\n    private IBlockState blockTypeOnCorrectPlacement;\n    private IBlockState blockTypeOnIncorrectPlacement;\n\n    private int dimension;\n\n    /**\n     * Attempt to parse the given object as a set of parameters for this handler.\n     *\n     * @param params the parameter block to parse\n     * @return true if the object made sense for this handler; false otherwise.\n     */\n    @Override\n    public boolean parseParameters(Object params) {\n        if (params == null || !(params instanceof RewardForStructureCopying))\n            return false;\n\n        RewardForStructureCopying rscparams = (RewardForStructureCopying) params;\n\n        BlockPos minPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMin());\n        BlockPos maxPlayerStructurePos = \n            this.blockPosFromPos(rscparams.getPlayerStructureBounds().getMax());\n        BlockPos minGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMin());\n        BlockPos maxGoalStructurePos = \n            this.blockPosFromPos(rscparams.getGoalStructureBounds().getMax());\n\n        this.playerStructureAABB = new AxisAlignedBB(minPlayerStructurePos, maxPlayerStructurePos);\n        this.goalStructureAABB = new AxisAlignedBB(minGoalStructurePos, maxGoalStructurePos);\n\n        assert(!playerStructureAABB.intersectsWith(goalStructureAABB));\n\n        this.structureVolume = volumeOfAABB(playerStructureAABB);\n        assert(this.structureVolume == volumeOfAABB(goalStructureAABB));\n\n        this.delta = new Vec3i(goalStructureAABB.minX - playerStructureAABB.minX,\n                goalStructureAABB.minY - playerStructureAABB.minY,\n                goalStructureAABB.minZ - playerStructureAABB.minZ);\n\n        this.rewardDensity = rscparams.getRewardDensity();\n\n        DrawBlockBasedObjectType blockBasedObjectType = rscparams.getBlockTypeOnCorrectPlacement();\n\n        this.blockTypeOnCorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        blockBasedObjectType = rscparams.getBlockTypeOnIncorrectPlacement();\n\n        this.blockTypeOnIncorrectPlacement = BlockDrawingHelper.applyModifications(\n                MinecraftTypeHelper.ParseBlockType(blockBasedObjectType.getType().value()),\n                blockBasedObjectType.getColour(),\n                blockBasedObjectType.getFace(),\n                blockBasedObjectType.getVariant());\n\n        this.dimension = rscparams.getDimension();\n\n        return true;\n    }\n\n    private BlockPos blockPosFromPos(@Nonnull Pos pos) {\n        return new BlockPos(pos.getX().intValueExact(), pos.getY().intValueExact(), \n                            pos.getZ().intValueExact());\n    }\n\n    private float volumeOfAABB(AxisAlignedBB axisAlignedBB) {\n        return (float) (axisAlignedBB.maxX - axisAlignedBB.minX + 1) *\n                (float) (axisAlignedBB.maxY - axisAlignedBB.minY + 1) *\n                (float) (axisAlignedBB.maxZ - axisAlignedBB.minZ + 1);\n    }\n\n    /**\n     * Get the reward value for the current Minecraft state.\n     *\n     * @param missionInit the MissionInit object for the currently running mission, \n     *        which may contain parameters for the reward requirements.\n     * @return a float determining the current reward signal for the learning agent\n     */\n    @Override\n    public float getReward(MissionInit missionInit) {\n        return 0;\n    }\n\n    /**\n     * Called once before the mission starts - use for any necessary initialisation.\n     *\n     * @param missionInit\n     */\n    @Override\n    public void prepare(MissionInit missionInit) {\n        try\n        {\n            if (MalmoMod.getPropertiesForCurrentThread().containsKey( QuitCode ))\n             MalmoMod.getPropertiesForCurrentThread().remove( QuitCode );\n        }\n        catch (Exception e)\n        {\n            System.out.println( Failed to get properties. );\n        }\n\n        MinecraftForge.EVENT_BUS.register(this);\n    }\n\n    /**\n     * Called once after the mission ends - use for any necessary cleanup.\n     */\n    @Override\n    public void cleanup() {\n        MinecraftForge.EVENT_BUS.unregister(this);\n    }\n}", 
            "title": "Prepare and Cleanup"
        }, 
        {
            "location": "/BuildBattle/Event_Handlers/", 
            "text": "Block Place Event\n\n\nThe first event handler we will write is the block place event handler.\nWe begin with the following code snippet: \n\n\n@SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n}\n\n\n\n\nA few things to note: \n\n\n\n\nAll Event Handlers must be declared public for \n    Forge to be able to access.\n\n\nThe annotation \n@SubscribeEvent\n should be used for registering\n    a method as an event handler.\n\n\nThe parameter of the event handler is crucial. Forge uses the type\n    of the parameter to infer what event the event handler wants a hook\n    into. In our case, we'd like a hook into the event where a block is\n    placed.\n\n\n\n\nWe now grab the \nWorld\n, which allows for querying blocks and\nentities, as well as a \nBlockPos\n denoting the position where a \nblock is being placed. \n\n\n@SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n        World w = e.world;\n        BlockPos pos = e.pos;\n}\n\n\n\n\nNow, we define another helper function which tells us whether a block \nposition, taken as a 3-D Vector, is within an Axis Aligned Bound Box: \n\n\npublic boolean pointInAABB(AxisAlignedBB aabb, Vec3 vec) {\n        return (aabb.minX \n= vec.xCoord \n aabb.maxX \n= vec.xCoord \n\n                aabb.minY \n= vec.yCoord \n aabb.maxY \n= vec.yCoord \n\n                aabb.minZ \n= vec.zCoord \n aabb.maxZ \n= vec.zCoord);\n}\n\n\n\n\nWe use the above function to cancel block place events that have the \nblock position as outside the player structure boundary: \n\n\n@SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n        World w = e.world;\n        BlockPos pos = e.pos;\n\n        if(!pointInAABB(playerStructureAABB, new Vec3(pos.getX(), pos.getY(), pos.getZ()))) {\n            e.setCanceled(true);\n            return;\n        }\n}\n\n\n\n\nNext, we find the corresponding goal structure block position and \ncalculate the reward to get the following. Note below that some Java \ncode comments, denoted with \n//\n, have been added for a better \nunderstanding.\n\n\n@SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n    World w = e.world;\n    BlockPos pos = e.pos;\n\n    // Cancel the build event if the player is trying to place a\n    // block outisde the player structure boundary.\n    if(!pointInAABB(playerStructureAABB, new Vec3(pos.getX(), pos.getY(), pos.getZ()))) {\n        e.setCanceled(true);\n        return;\n    }\n\n    BlockPos goalPos = pos.add(delta);\n\n    // This block was air, and a correct block has been placed (Positive Reward).\n    if (w.getBlockState(pos).equals(w.getBlockState(goalPos))) {\n\n        // When a correct block is placed, change the state of both the \n        // block being placed and the corresponding goal structure block to \n        // blockTypeOnCorrectPlacement\n        if(blockTypeOnCorrectPlacement != null) {\n\n            // blockStateSave store the current goal block state before it \n            // changes to the blockTypeOnCurrentPlacement. This will be used \n            // when a player tries to break the block being placed now to \n            // change the corresponding goal block back to what it was.\n            blockStateSave.put(goalPos, w.getBlockState(goalPos));\n\n            w.setBlockState(pos, blockTypeOnCorrectPlacement);\n            w.setBlockState(goalPos, blockTypeOnCorrectPlacement);\n        }\n\n        // If the Reward Density is PER_BLOCK or MISSION_END, add the \n        // delta change in exact similarity (1 / Structure Volume) \n        if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n           rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n            reward += 1 .0F/ structureVolume;\n\n        // Else, the reward density is ACCUMULATED. Add the total similarity to the reward. \n        // Store the total similarity to bootstrapReward.\n        else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n            reward = reward + (reward + 1.0F / structureVolume);\n            bootstrapReward += 1.0F / structureVolume;\n        }\n    }\n\n    else {\n        // 1. Case where both player structure blocks and goal structure blocks were Air,\n        // no need to place a block (Reward Penalty).\n        // 2. Case where the block being placed is not the same as the goal structure block.\n        if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n           rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n                reward -= 1 / structureVolume;\n        else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n                reward = (reward - (1.0F / structureVolume)) / 2.0F;\n                bootstrapReward -= 1.0F / structureVolume;\n        }\n\n        if(blockTypeOnIncorrectPlacement != null) {\n            w.setBlockState(pos, blockTypeOnIncorrectPlacement);\n        }\n    }\n}\n\n\n\n\nBlock Break Event\n\n\nThe second event handler we will write is very similar, the code \nfor which is given below.\n\n\n@SubscribeEvent\npublic void onBlockBreak(BlockEvent.BreakEvent e) {\n    World w = e.world;\n    BlockPos pos = e.pos;\n\n    if(!pointInAABB(playerStructureAABB, new Vec3(pos.getX(), pos.getY(), pos.getZ()))) {\n        e.setCanceled(true);\n        return;\n    }\n\n    BlockPos goalPos = pos.add(delta);\n\n    // Case where the block states matched, no need to break \n    // the player structure block (Reward Penalty).\n    if (w.getBlockState(pos).equals(w.getBlockState(goalPos))) {\n        if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n           rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n            reward -= 1 / structureVolume;\n        else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n            reward = (reward - (1 / structureVolume)) / 2;\n            bootstrapReward -= 1 / structureVolume;\n        }\n\n        if(blockTypeOnCorrectPlacement != null) {\n            w.setBlockState(goalPos, blockStateSave.get(goalPos));\n        }\n    }\n\n    else\n    {\n        // Goal Structure block is an Air Block or is a different block than the \n        // player structure block. Breaking increases similarity (Positive Reward).\n        if(w.isAirBlock(goalPos)) {\n            if (rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n                rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n                reward += 1 / structureVolume;\n            else if (rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n                reward = reward + (reward + 1 / structureVolume);\n                bootstrapReward += 1 / structureVolume;\n            }\n        }\n    }\n}", 
            "title": "Event Handlers"
        }, 
        {
            "location": "/BuildBattle/Event_Handlers/#block-place-event", 
            "text": "The first event handler we will write is the block place event handler.\nWe begin with the following code snippet:   @SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n}  A few things to note:    All Event Handlers must be declared public for \n    Forge to be able to access.  The annotation  @SubscribeEvent  should be used for registering\n    a method as an event handler.  The parameter of the event handler is crucial. Forge uses the type\n    of the parameter to infer what event the event handler wants a hook\n    into. In our case, we'd like a hook into the event where a block is\n    placed.   We now grab the  World , which allows for querying blocks and\nentities, as well as a  BlockPos  denoting the position where a \nblock is being placed.   @SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n        World w = e.world;\n        BlockPos pos = e.pos;\n}  Now, we define another helper function which tells us whether a block \nposition, taken as a 3-D Vector, is within an Axis Aligned Bound Box:   public boolean pointInAABB(AxisAlignedBB aabb, Vec3 vec) {\n        return (aabb.minX  = vec.xCoord   aabb.maxX  = vec.xCoord  \n                aabb.minY  = vec.yCoord   aabb.maxY  = vec.yCoord  \n                aabb.minZ  = vec.zCoord   aabb.maxZ  = vec.zCoord);\n}  We use the above function to cancel block place events that have the \nblock position as outside the player structure boundary:   @SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n        World w = e.world;\n        BlockPos pos = e.pos;\n\n        if(!pointInAABB(playerStructureAABB, new Vec3(pos.getX(), pos.getY(), pos.getZ()))) {\n            e.setCanceled(true);\n            return;\n        }\n}  Next, we find the corresponding goal structure block position and \ncalculate the reward to get the following. Note below that some Java \ncode comments, denoted with  // , have been added for a better \nunderstanding.  @SubscribeEvent\npublic void onBlockPlacement(BlockEvent.PlaceEvent e) {\n\n    World w = e.world;\n    BlockPos pos = e.pos;\n\n    // Cancel the build event if the player is trying to place a\n    // block outisde the player structure boundary.\n    if(!pointInAABB(playerStructureAABB, new Vec3(pos.getX(), pos.getY(), pos.getZ()))) {\n        e.setCanceled(true);\n        return;\n    }\n\n    BlockPos goalPos = pos.add(delta);\n\n    // This block was air, and a correct block has been placed (Positive Reward).\n    if (w.getBlockState(pos).equals(w.getBlockState(goalPos))) {\n\n        // When a correct block is placed, change the state of both the \n        // block being placed and the corresponding goal structure block to \n        // blockTypeOnCorrectPlacement\n        if(blockTypeOnCorrectPlacement != null) {\n\n            // blockStateSave store the current goal block state before it \n            // changes to the blockTypeOnCurrentPlacement. This will be used \n            // when a player tries to break the block being placed now to \n            // change the corresponding goal block back to what it was.\n            blockStateSave.put(goalPos, w.getBlockState(goalPos));\n\n            w.setBlockState(pos, blockTypeOnCorrectPlacement);\n            w.setBlockState(goalPos, blockTypeOnCorrectPlacement);\n        }\n\n        // If the Reward Density is PER_BLOCK or MISSION_END, add the \n        // delta change in exact similarity (1 / Structure Volume) \n        if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n           rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n            reward += 1 .0F/ structureVolume;\n\n        // Else, the reward density is ACCUMULATED. Add the total similarity to the reward. \n        // Store the total similarity to bootstrapReward.\n        else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n            reward = reward + (reward + 1.0F / structureVolume);\n            bootstrapReward += 1.0F / structureVolume;\n        }\n    }\n\n    else {\n        // 1. Case where both player structure blocks and goal structure blocks were Air,\n        // no need to place a block (Reward Penalty).\n        // 2. Case where the block being placed is not the same as the goal structure block.\n        if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n           rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n                reward -= 1 / structureVolume;\n        else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n                reward = (reward - (1.0F / structureVolume)) / 2.0F;\n                bootstrapReward -= 1.0F / structureVolume;\n        }\n\n        if(blockTypeOnIncorrectPlacement != null) {\n            w.setBlockState(pos, blockTypeOnIncorrectPlacement);\n        }\n    }\n}", 
            "title": "Block Place Event"
        }, 
        {
            "location": "/BuildBattle/Event_Handlers/#block-break-event", 
            "text": "The second event handler we will write is very similar, the code \nfor which is given below.  @SubscribeEvent\npublic void onBlockBreak(BlockEvent.BreakEvent e) {\n    World w = e.world;\n    BlockPos pos = e.pos;\n\n    if(!pointInAABB(playerStructureAABB, new Vec3(pos.getX(), pos.getY(), pos.getZ()))) {\n        e.setCanceled(true);\n        return;\n    }\n\n    BlockPos goalPos = pos.add(delta);\n\n    // Case where the block states matched, no need to break \n    // the player structure block (Reward Penalty).\n    if (w.getBlockState(pos).equals(w.getBlockState(goalPos))) {\n        if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n           rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n            reward -= 1 / structureVolume;\n        else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n            reward = (reward - (1 / structureVolume)) / 2;\n            bootstrapReward -= 1 / structureVolume;\n        }\n\n        if(blockTypeOnCorrectPlacement != null) {\n            w.setBlockState(goalPos, blockStateSave.get(goalPos));\n        }\n    }\n\n    else\n    {\n        // Goal Structure block is an Air Block or is a different block than the \n        // player structure block. Breaking increases similarity (Positive Reward).\n        if(w.isAirBlock(goalPos)) {\n            if (rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK || \n                rewardDensity == RewardDensityForBuildAndBreak.MISSION_END)\n                reward += 1 / structureVolume;\n            else if (rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n                reward = reward + (reward + 1 / structureVolume);\n                bootstrapReward += 1 / structureVolume;\n            }\n        }\n    }\n}", 
            "title": "Block Break Event"
        }, 
        {
            "location": "/BuildBattle/Summary/", 
            "text": "Logging the initial similarity and finalizing the Reward Handler\n\n\nWe still need to calculate the initial similarity between the two\nstructures. The idea is that some portion of the player structure\ncan be given when the mission starts as a hint, say 80%. The similarity\nwill then be 0.8 times the structure volume. The code for calculating\nthis, with a simple triple nested for-loop, is given below:\n\n\nvoid logInitialSimilarity( World w ) {\n\n    // No need to calculate the initial similarity\n    if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED || \n       rewardDensity == RewardDensityForBuildAndBreak.MISSION_END) {\n\n        Integer numExactMatchBlocks = 0;\n\n        for (int x = (int) playerStructureAABB.minX; x \n= playerStructureAABB.maxX; x++) {\n            for (int y = (int) playerStructureAABB.minY; y \n= playerStructureAABB.maxY; y++) {\n                for (int z = (int) playerStructureAABB.minZ; z \n= playerStructureAABB.maxZ; z++) {\n                    BlockPos playerStructurePos = new BlockPos(x, y, z);\n                    BlockPos goalStructurePos = playerStructurePos.add(delta);\n\n                    if (w.getBlockState(playerStructurePos).equals(goalStructurePos))\n                        numExactMatchBlocks++;\n                }\n            }\n        }\n\n        reward =  (float) numExactMatchBlocks / structureVolume;\n        bootstrapReward = reward;\n    }\n}\n\n\n\n\nFinally, we can write the function that returns rewards that get sent to\nthe agent:\n\n\n@Override\npublic void getReward(MissionInit missionInit, MultidimensionalReward multidimReward) {\n    if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK) {\n        Float f = this.reward;\n        this.reward = 0.0F;\n        multidimReward.add( this.dimension, f );\n    }\n\n    else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n        Float f = reward;\n        reward = bootstrapReward;\n        multidimReward.add( this.dimension, f );\n    }\n\n    else  { // rewardDensity == RewardDensityForBuildAndBreak.MISSION_END\n        try {\n            // Return a reward only if the QuitCode is present.\n            Hashtable\nString, Object\n properties = MalmoMod.getPropertiesForCurrentThread();\n            if (properties.containsKey(\nQuitCode\n))\n                multidimReward.add( this.dimension, this.reward );\n            else\n                multidimReward.add( this.dimension, 0 );\n        }\n\n        catch (Exception e)\n        {\n            System.out.print(\nCaught exception getting properties while searching for QuitCode!\n);\n            // FMLCommonHandler.instance().exitJava(-1, false);\n            // Note: The above commented line of code is a simple way to quit Minecraft on errors. \n            // For the purposes of this caught exception, notifying the user with \n            // a print output suffices.\n        }\n    }\n}\n\n\n\n\nConclusion\n\n\nHopefully everything worked all right and you enjoyed constructing the build battle task.\nPlease do take a look at and review the resources provided as necessary.\nOther than that, what's left is now arguably the more fun part: to create missions using the Reward Handler we have added to the Mod and to create AI agents that can solve it.\nFor the former, the sample missions provided will help, but it essentially boils down to writing some XML. As for the latter, it's really an open question! Some instances of the build battle task we have defined here are easy (say small open 2-dimensional structures.) In general, this task is somewhat easy for humans (try it yourself by entering into Human mode with the Enter key once you have started a mission.) However, it is not so easy and tractable for current AI and reinforcement learning agents! The idea of the platform is indeed this, to be able to create tasks with a broad spectrum of difficulties and by working at it's forefront, advance the state of AI.", 
            "title": "Summary"
        }, 
        {
            "location": "/BuildBattle/Summary/#logging-the-initial-similarity-and-finalizing-the-reward-handler", 
            "text": "We still need to calculate the initial similarity between the two\nstructures. The idea is that some portion of the player structure\ncan be given when the mission starts as a hint, say 80%. The similarity\nwill then be 0.8 times the structure volume. The code for calculating\nthis, with a simple triple nested for-loop, is given below:  void logInitialSimilarity( World w ) {\n\n    // No need to calculate the initial similarity\n    if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED || \n       rewardDensity == RewardDensityForBuildAndBreak.MISSION_END) {\n\n        Integer numExactMatchBlocks = 0;\n\n        for (int x = (int) playerStructureAABB.minX; x  = playerStructureAABB.maxX; x++) {\n            for (int y = (int) playerStructureAABB.minY; y  = playerStructureAABB.maxY; y++) {\n                for (int z = (int) playerStructureAABB.minZ; z  = playerStructureAABB.maxZ; z++) {\n                    BlockPos playerStructurePos = new BlockPos(x, y, z);\n                    BlockPos goalStructurePos = playerStructurePos.add(delta);\n\n                    if (w.getBlockState(playerStructurePos).equals(goalStructurePos))\n                        numExactMatchBlocks++;\n                }\n            }\n        }\n\n        reward =  (float) numExactMatchBlocks / structureVolume;\n        bootstrapReward = reward;\n    }\n}  Finally, we can write the function that returns rewards that get sent to\nthe agent:  @Override\npublic void getReward(MissionInit missionInit, MultidimensionalReward multidimReward) {\n    if(rewardDensity == RewardDensityForBuildAndBreak.PER_BLOCK) {\n        Float f = this.reward;\n        this.reward = 0.0F;\n        multidimReward.add( this.dimension, f );\n    }\n\n    else if(rewardDensity == RewardDensityForBuildAndBreak.ACCUMULATED) {\n        Float f = reward;\n        reward = bootstrapReward;\n        multidimReward.add( this.dimension, f );\n    }\n\n    else  { // rewardDensity == RewardDensityForBuildAndBreak.MISSION_END\n        try {\n            // Return a reward only if the QuitCode is present.\n            Hashtable String, Object  properties = MalmoMod.getPropertiesForCurrentThread();\n            if (properties.containsKey( QuitCode ))\n                multidimReward.add( this.dimension, this.reward );\n            else\n                multidimReward.add( this.dimension, 0 );\n        }\n\n        catch (Exception e)\n        {\n            System.out.print( Caught exception getting properties while searching for QuitCode! );\n            // FMLCommonHandler.instance().exitJava(-1, false);\n            // Note: The above commented line of code is a simple way to quit Minecraft on errors. \n            // For the purposes of this caught exception, notifying the user with \n            // a print output suffices.\n        }\n    }\n}", 
            "title": "Logging the initial similarity and finalizing the Reward Handler"
        }, 
        {
            "location": "/BuildBattle/Summary/#conclusion", 
            "text": "Hopefully everything worked all right and you enjoyed constructing the build battle task.\nPlease do take a look at and review the resources provided as necessary.\nOther than that, what's left is now arguably the more fun part: to create missions using the Reward Handler we have added to the Mod and to create AI agents that can solve it.\nFor the former, the sample missions provided will help, but it essentially boils down to writing some XML. As for the latter, it's really an open question! Some instances of the build battle task we have defined here are easy (say small open 2-dimensional structures.) In general, this task is somewhat easy for humans (try it yourself by entering into Human mode with the Enter key once you have started a mission.) However, it is not so easy and tractable for current AI and reinforcement learning agents! The idea of the platform is indeed this, to be able to create tasks with a broad spectrum of difficulties and by working at it's forefront, advance the state of AI.", 
            "title": "Conclusion"
        }
    ]
}